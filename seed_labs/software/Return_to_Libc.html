

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Return-to-libc Attack Lab &mdash; Network Security Lab  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Environment Variable and Program Lab" href="Environment_Variable_and_SetUID.html" />
    <link rel="prev" title="Buffer Overflow Attack Lab (Server Version)" href="Buffer_Overflow_Server.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Network Security Lab
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../xie/xie_labs.html">Xie Labs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../seed_index.html">SEED Labs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../crypto/crypto_index.html">Cryptography Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hardware/hardware_index.html">Hardware Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mobile/mobile_index.html">Mobile Security Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/network_index.html">Network Security Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../web/web_index.html">Web Security Labs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="software_index.html">Software Security Labs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="Shellcode.html">Shellcode Development Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Buffer_Overflow_Setuid.html">Buffer Overflow Attack Lab (Set-UID Version)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Buffer_Overflow_Server.html">Buffer Overflow Attack Lab (Server Version)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Return-to-libc Attack Lab</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#environment-setup">Environment Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-1-finding-out-the-addresses-of-libc-functions">Task 1: Finding out the Addresses of <code class="docutils literal notranslate"><span class="pre">libc</span></code> Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-2-putting-the-shell-string-in-the-memory">Task 2: Putting the shell string in the memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-3-launching-the-attack">Task 3: Launching the Attack</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-4-defeat-shells-countermeasure">Task 4: Defeat Shell’s countermeasure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-5-optional-return-oriented-programming">Task 5 (Optional): Return-Oriented Programming</a></li>
<li class="toctree-l4"><a class="reference internal" href="#guidelines-understanding-the-function-call-mechanism">Guidelines: Understanding the Function Call Mechanism</a></li>
<li class="toctree-l4"><a class="reference internal" href="#submission">Submission</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Environment_Variable_and_SetUID.html">Environment Variable and Program Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Race_Condition.html">Race Condition Vulnerability Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Dirty_COW.html">Dirty COW Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Format_String.html">Format String Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Shellshock.html">Shellshock Attack Lab</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://taylorelder.com/projects.html">Return Back To Website</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Network Security Lab</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../seed_index.html">SEED Labs</a> &raquo;</li>
        
          <li><a href="software_index.html">Software Security Labs</a> &raquo;</li>
        
      <li>Return-to-libc Attack Lab</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/seed_labs/software/Return_to_Libc.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="return-to-libc-attack-lab">
<h1>Return-to-libc Attack Lab<a class="headerlink" href="#return-to-libc-attack-lab" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The learning objective of this lab is for students to gain the
first-hand experience on an interesting variant of buffer-overflow
attack; this attack can bypass an existing protection scheme currently
implemented in major Linux operating systems. A common way to exploit a
buffer-overflow vulnerability is to overflow the buffer with a malicious
shellcode, and then cause the vulnerable program to jump to the
shellcode stored in the stack. To prevent these types of attacks, some
operating systems allow programs to make their stacks non-executable;
therefore, jumping to the shellcode causes the program to fail.</p>
<p>Unfortunately, the above protection scheme is not fool-proof. There
exists a variant of buffer-overflow attacks called <em>Return-to-libc</em>,
which does not need an executable stack; it does not even use shellcode.
Instead, it causes the vulnerable program to jump to some existing code,
such as the <code class="docutils literal notranslate"><span class="pre">system()</span></code> function in the <code class="docutils literal notranslate"><span class="pre">libc</span></code> library, which is
already loaded into a process’s memory space.</p>
<p>In this lab, students are given a program with a buffer-overflow
vulnerability; their task is to develop a Return-to-libc attack to
exploit the vulnerability and finally to gain the root privilege. In
addition to the attacks, students will be guided to walk through some
protection schemes implemented in Ubuntu to counter buffer-overflow
attacks. This lab covers the following topics:</p>
<ul class="simple">
<li><p>Buffer overflow vulnerability</p></li>
<li><p>Stack layout in a function invocation and Non-executable stack</p></li>
<li><p>Return-to-libc attack and Return-Oriented Programming (ROP)</p></li>
</ul>
<p><strong>Readings and videos.</strong> Detailed coverage of the return-to-libc attack can be found in the
following:</p>
<ul class="simple">
<li><p>Chapter 5 of the SEED Book, Computer &amp; Internet Security: A Hands-on Approach, 2nd Edition, by
Wenliang Du. See details at <a class="reference external" href="https://www.handsonsecurity.net">https://www.handsonsecurity.net</a>.</p></li>
<li><p>Section 5 of the SEED Lecture at Udemy, Computer Security: A Hands-on Approach, by Wenliang
Du. See details at <a class="reference external" href="https://www.handsonsecurity.net/video.html">https://www.handsonsecurity.net/video.html</a>.</p></li>
</ul>
<p><strong>Lab environment.</strong> This lab has been tested on the SEED Ubuntu 20.04 VM. You can download a pre-built
image from the SEED website, and run the SEED VM on your own computer. However, most of the SEED
labs can be conducted on the cloud, and you can follow our instruction to create a SEED VM on the cloud.</p>
<p><strong>Note for instructors.</strong> Instructors can customize this lab by choosing a value for the buffer
size in the vulnerable program. See
Section 2.3 for details.</p>
</div>
<div class="section" id="environment-setup">
<h2>Environment Setup<a class="headerlink" href="#environment-setup" title="Permalink to this headline">¶</a></h2>
<div class="section" id="note-on-x86-and-x64-architectures">
<h3>Note on x86 and x64 Architectures<a class="headerlink" href="#note-on-x86-and-x64-architectures" title="Permalink to this headline">¶</a></h3>
<p>The return-to-libc attack on the x64 machines (64-bit) is much more
difficult than that on the x86 machines (32-bit). Although the SEED
Ubuntu 20.04 VM is a 64-bit machine, we decide to keep using the 32-bit
programs (x64 is compatible with x86, so 32-bit programs can still run
on x64 machines). In the future, we may introduce a 64-bit version for
this lab. Therefore, in this lab, when we compile programs using
<code class="docutils literal notranslate"><span class="pre">gcc</span></code>, we always use the <code class="docutils literal notranslate"><span class="pre">-m32</span></code> flag, which means compiling the
program into 32-bit binary.</p>
</div>
<div class="section" id="turning-off-countermeasures">
<h3>Turning off countermeasures<a class="headerlink" href="#turning-off-countermeasures" title="Permalink to this headline">¶</a></h3>
<p>You can execute the lab tasks using our pre-built Ubuntu virtual
machines. Ubuntu and other Linux distributions have implemented several
security mechanisms to make the buffer-overflow attack difficult. To
simplify our attacks, we need to disable them first.</p>
<p><strong>Address Space Randomization.</strong> Ubuntu and several other Linux-based systems use address space
randomization to randomize the starting address of heap and stack,
making guessing the exact addresses difficult. Guessing addresses is one
of the critical steps of buffer-overflow attacks. In this lab, we
disable this feature using the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo sysctl -w kernel.randomize_va_space=0
</pre></div>
</div>
<p><strong>The StackGuard Protection Scheme.</strong> The <code class="docutils literal notranslate"><span class="pre">gcc</span></code> compiler implements a security mechanism called <em>StackGuard</em>
to prevent buffer overflows. In the presence of this protection, buffer
overflow attacks do not work. We can disable this protection during the
compilation using the <em>-fno-stack-protector</em> option. For example, to
compile a program <code class="docutils literal notranslate"><span class="pre">example.c</span></code> with StackGuard disabled, we can do the
following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gcc -m32 -fno-stack-protector example.c
</pre></div>
</div>
<p><strong>Non-Executable Stack.</strong> Ubuntu used to allow executable stacks, but this has now changed. The
binary images of programs (and shared libraries) must declare whether
they require executable stacks or not, i.e., they need to mark a field
in the program header. Kernel or dynamic linker uses this marking to
decide whether to make the stack of this running program executable or
non-executable. This marking is done automatically by the recent
versions of gcc, and by default, stacks are set to be non-executable. To
change that, use the following option when compiling programs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>For executable stack:
$ gcc -m32 -z execstack  -o test test.c

For non-executable stack:
$ gcc -m32 -z noexecstack  -o test test.c
</pre></div>
</div>
<p>Because the objective of this lab is to show that the non-executable
stack protection does not work, you should always compile your program
using the “-z noexecstack” option in this lab.</p>
<p><strong>Configuring ``/bin/sh``.</strong> In Ubuntu 20.04, the <code class="docutils literal notranslate"><span class="pre">/bin/sh</span></code> symbolic link points to the
<code class="docutils literal notranslate"><span class="pre">/bin/dash</span></code> shell. The <code class="docutils literal notranslate"><span class="pre">dash</span></code> shell has a countermeasure that
prevents itself from being executed in a process. If <code class="docutils literal notranslate"><span class="pre">dash</span></code> is
executed in a process, it immediately changes the effective user ID to
the process’s real user ID, essentially dropping its privilege.</p>
<p>Since our victim program is a program, and our attack uses the
<code class="docutils literal notranslate"><span class="pre">system()</span></code> function to run a command of our choice. This function does
not run our command directly; it invokes <code class="docutils literal notranslate"><span class="pre">/bin/sh</span></code> to run our command.
Therefore, the countermeasure in <code class="docutils literal notranslate"><span class="pre">/bin/dash</span></code> immediately drops the
privilege before executing our command, making our attack more
difficult. To disable this protection, we link <code class="docutils literal notranslate"><span class="pre">/bin/sh</span></code> to another
shell that does not have such a countermeasure. We have installed a
shell program called <code class="docutils literal notranslate"><span class="pre">zsh</span></code> in our Ubuntu 16.04 VM. We use the
following commands to link <code class="docutils literal notranslate"><span class="pre">/bin/sh</span></code> to <code class="docutils literal notranslate"><span class="pre">zsh</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo ln -sf /bin/zsh /bin/sh
</pre></div>
</div>
<p>It should be noted that the countermeasure implemented in <code class="docutils literal notranslate"><span class="pre">dash</span></code> can
be circumvented. We will do that in a later task.</p>
</div>
<div class="section" id="the-vulnerable-program">
<h3>The Vulnerable Program<a class="headerlink" href="#the-vulnerable-program" title="Permalink to this headline">¶</a></h3>
<p>Below is Listing 1: The vulnerable program (<code class="docutils literal notranslate"><span class="pre">retlib.c</span></code>).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#ifndef BUF_SIZE
#define BUF_SIZE 12
#endif

int bof(char *str)
{
    char buffer[BUF_SIZE];
    unsigned int *framep;

    // Copy ebp into framep
    asm(&quot;movl %%ebp, %0&quot; : &quot;=r&quot; (framep));

    /* print out information for experiment purpose */
    printf(&quot;Address of buffer[] inside bof():  0x%.8x\n&quot;, (unsigned)buffer);
    printf(&quot;Frame Pointer value inside bof():  0x%.8x\n&quot;, (unsigned)framep);

    strcpy(buffer, str);   &lt;-- buffer overflow!

    return 1;
}

int main(int argc, char **argv)
{
   char input[1000];
   FILE *badfile;

   badfile = fopen(&quot;badfile&quot;, &quot;r&quot;);
   int length = fread(input, sizeof(char), 1000, badfile);
   printf(&quot;Address of input[] inside main():  0x%x\n&quot;, (unsigned int) input);
   printf(&quot;Input size: %d\n&quot;, length);

   bof(input);

   printf(&quot;(^_^)(^_^) Returned Properly (^_^)(^_^)\n&quot;);
   return 1;
}

// This function will be used in the optional task
void foo(){
    static int i = 1;
    printf(&quot;Function foo() is invoked %d times\n&quot;, i++);
    return;
}
</pre></div>
</div>
<p>The above program has a buffer overflow vulnerability. It first reads an
input up to <code class="docutils literal notranslate"><span class="pre">1000</span></code> bytes from a file called <code class="docutils literal notranslate"><span class="pre">badfile</span></code>. It then
passes the input data to the <code class="docutils literal notranslate"><span class="pre">bof()</span></code> function, which copies the input
to its internal buffer using <code class="docutils literal notranslate"><span class="pre">strcpy()</span></code>. However, the internal
buffer’s size is less than <code class="docutils literal notranslate"><span class="pre">1000</span></code>, so here is potential
buffer-overflow vulnerability.</p>
<p>This program is a root-owned program, so if a normal user can exploit
this buffer overflow vulnerability, the user might be able to get a root
shell. It should be noted that the program gets its input from a file
called <code class="docutils literal notranslate"><span class="pre">badfile</span></code>, which is provided by users. Therefore, we can
construct the file in a way such that when the vulnerable program copies
the file contents into its buffer, a root shell can be spawned.</p>
<p><strong>Compilation.</strong> Let us first compile the code and turn it into a root-owned program. Do
not forget to include the <code class="docutils literal notranslate"><span class="pre">-fno-stack-protector</span></code> option (for turning
off the StackGuard protection) and the <code class="docutils literal notranslate"><span class="pre">&quot;-z</span> <span class="pre">noexecstack&quot;</span></code> option (for
turning on the non-executable stack protection). It should also be noted
that changing ownership must be done before turning on the bit, because
ownership changes cause the bit to be turned off. All these commands are
included in the provided <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Note: N should be replaced by the value set by the instructor
$ gcc -m32 -DBUF_SIZE=N -fno-stack-protector -z noexecstack -o retlib retlib.c
$ sudo chown root retlib
$ sudo chmod 4755 retlib
</pre></div>
</div>
<p><strong>For instructors.</strong> To prevent students from using the solutions from the past (or from
those posted on the Internet), instructors can change the value for
<code class="docutils literal notranslate"><span class="pre">BUF_SIZE</span></code> by requiring students to compile the code using a different
<code class="docutils literal notranslate"><span class="pre">BUF_SIZE</span></code> value. Without the <code class="docutils literal notranslate"><span class="pre">-DBUF_SIZE</span></code> option, <code class="docutils literal notranslate"><span class="pre">BUF_SIZE</span></code> is
set to the default value <code class="docutils literal notranslate"><span class="pre">12</span></code> (defined in the program). When this
value changes, the layout of the stack will change, and the solution
will be different. Students should ask their instructors for the value
of <code class="docutils literal notranslate"><span class="pre">N</span></code>. The value of <code class="docutils literal notranslate"><span class="pre">N</span></code> can be set in the provided <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> and
<code class="docutils literal notranslate"><span class="pre">N</span></code> can be from 10 to 800.</p>
</div>
</div>
<div class="section" id="task-1-finding-out-the-addresses-of-libc-functions">
<h2>Task 1: Finding out the Addresses of <code class="docutils literal notranslate"><span class="pre">libc</span></code> Functions<a class="headerlink" href="#task-1-finding-out-the-addresses-of-libc-functions" title="Permalink to this headline">¶</a></h2>
<p>In , when a program runs, the <code class="docutils literal notranslate"><span class="pre">libc</span></code> library will be loaded into
memory. When the memory address randomization is turned off, for the
same program, the library is always loaded in the same memory address
(for different programs, the memory addresses of the <code class="docutils literal notranslate"><span class="pre">libc</span></code> library
may be different). Therefore, we can easily find out the address of
<code class="docutils literal notranslate"><span class="pre">system()</span></code> using a debugging tool such as <code class="docutils literal notranslate"><span class="pre">gdb</span></code>. Namely, we can
debug the target program <code class="docutils literal notranslate"><span class="pre">retlib</span></code>. Even though the program is a
root-owned program, we can still debug it, except that the privilege
will be dropped (i.e., the effective user ID will be the same as the
real user ID). Inside <code class="docutils literal notranslate"><span class="pre">gdb</span></code>, we need to type the <code class="docutils literal notranslate"><span class="pre">run</span></code> command to
execute the target program once, otherwise, the library code will not be
loaded. We use the <code class="docutils literal notranslate"><span class="pre">p</span></code> command (or <code class="docutils literal notranslate"><span class="pre">print</span></code>) to print out the address
of the <code class="docutils literal notranslate"><span class="pre">system()</span></code> and <code class="docutils literal notranslate"><span class="pre">exit()</span></code> functions (we will need <code class="docutils literal notranslate"><span class="pre">exit()</span></code>
later on).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ touch badfile
$ gdb -q retlib     &lt;--- Use &quot;Quiet&quot; mode
Reading symbols from ./retlib...
(No debugging symbols found in ./retlib)
gdb-peda$ break main
Breakpoint 1 at 0x1327
gdb-peda$ run
......
Breakpoint 1, 0x56556327 in main ()
gdb-peda$ p system
$1 = {&lt;text variable, no debug info&gt;} 0xf7e12420 &lt;system&gt;
gdb-peda$ p exit
$2 = {&lt;text variable, no debug info&gt;} 0xf7e04f80 &lt;exit&gt;
gdb-peda$ quit
</pre></div>
</div>
<p>It should be noted that even for the same program, if we change it from
a program to a non-program, the <code class="docutils literal notranslate"><span class="pre">libc</span></code> library may not be loaded into
the same location. Therefore, when we debug the program, we need to
debug the target program; otherwise, the address we get may be
incorrect.</p>
<p><strong>Running ``gdb`` in batch mode.</strong> If you prefer to run <code class="docutils literal notranslate"><span class="pre">gdb</span></code> in a batch mode, you can put the <code class="docutils literal notranslate"><span class="pre">gdb</span></code>
commands in a file, and then ask <code class="docutils literal notranslate"><span class="pre">gdb</span></code> to execute the commands from
this file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat gdb_command.txt
break main
run
p system
p exit
quit
$ gdb -q -batch -x gdb_command.txt ./retlib
...
Breakpoint 1, 0x56556327 in main ()
$1 = {&lt;text variable, no debug info&gt;} 0xf7e12420 &lt;system&gt;
$2 = {&lt;text variable, no debug info&gt;} 0xf7e04f80 &lt;exit&gt;
</pre></div>
</div>
</div>
<div class="section" id="task-2-putting-the-shell-string-in-the-memory">
<h2>Task 2: Putting the shell string in the memory<a class="headerlink" href="#task-2-putting-the-shell-string-in-the-memory" title="Permalink to this headline">¶</a></h2>
<p>Our attack strategy is to jump to the <code class="docutils literal notranslate"><span class="pre">system()</span></code> function and get it
to execute an arbitrary command. Since we would like to get a shell
prompt, we want the <code class="docutils literal notranslate"><span class="pre">system()</span></code> function to execute the <code class="docutils literal notranslate"><span class="pre">&quot;/bin/sh&quot;</span></code>
program. Therefore, the command string <code class="docutils literal notranslate"><span class="pre">&quot;/bin/sh&quot;</span></code> must be put in the
memory first and we have to know its address (this address needs to be
passed to the <code class="docutils literal notranslate"><span class="pre">system()</span></code> function). There are many ways to achieve
these goals; we choose a method that uses environment variables.
Students are encouraged to use other approaches.</p>
<p>When we execute a program from a shell prompt, the shell actually spawns
a child process to execute the program, and all the exported shell
variables become the environment variables of the child process. This
creates an easy way for us to put some arbitrary string in the child
process’s memory. Let us define a new shell variable <code class="docutils literal notranslate"><span class="pre">MYSHELL</span></code>, and
let it contain the string <code class="docutils literal notranslate"><span class="pre">&quot;/bin/sh&quot;</span></code>. From the following commands, we
can verify that the string gets into the child process, and it is
printed out by the <code class="docutils literal notranslate"><span class="pre">env</span></code> command running inside the child process.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ export MYSHELL=/bin/sh
$ env | grep MYSHELL
MYSHELL=/bin/sh
</pre></div>
</div>
<p>We will use the address of this variable as an argument to system()
call. The location of this variable in the memory can be found out
easily using the following program:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void main(){
   char* shell =  getenv(&quot;MYSHELL&quot;);
   if (shell)
      printf(&quot;%x\n&quot;, (unsigned int)shell);
}
</pre></div>
</div>
<p>Compile the code above into a binary called <code class="docutils literal notranslate"><span class="pre">prtenv</span></code>. If the address
randomization is turned off, you will find out that the same address is
printed out. When you run the vulnerable program <code class="docutils literal notranslate"><span class="pre">retlib</span></code> inside the
same terminal, the address of the environment variable will be the same.
You can verify that by putting the code above inside <code class="docutils literal notranslate"><span class="pre">retlib.c</span></code>.
However, the length of the program name does make a difference. That’s
why we choose 6 characters for the program name <code class="docutils literal notranslate"><span class="pre">prtenv</span></code> to match the
length of <code class="docutils literal notranslate"><span class="pre">retlib</span></code>.</p>
</div>
<div class="section" id="task-3-launching-the-attack">
<h2>Task 3: Launching the Attack<a class="headerlink" href="#task-3-launching-the-attack" title="Permalink to this headline">¶</a></h2>
<p>We are ready to create the content of <code class="docutils literal notranslate"><span class="pre">badfile</span></code>. Since the content
involves some binary data (e.g., the address of the <code class="docutils literal notranslate"><span class="pre">libc</span></code> functions),
we can use Python to do the construction. We provide a skeleton of the
code in the following, with the essential parts left for you to fill
out.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env python3
import sys

# Fill content with non-zero values
content = bytearray(0xaa for i in range(300))

X = 0
sh_addr = 0x00000000       # The address of &quot;/bin/sh&quot;
content[X:X+4] = (sh_addr).to_bytes(4,byteorder=&#39;little&#39;)

Y = 0
system_addr = 0x00000000   # The address of system()
content[Y:Y+4] = (system_addr).to_bytes(4,byteorder=&#39;little&#39;)

Z = 0
exit_addr = 0x00000000     # The address of exit()
content[Z:Z+4] = (exit_addr).to_bytes(4,byteorder=&#39;little&#39;)

# Save content to a file
with open(&quot;badfile&quot;, &quot;wb&quot;) as f:
  f.write(content)
</pre></div>
</div>
<p>You need to figure out the three addresses and the values for <code class="docutils literal notranslate"><span class="pre">X</span></code>,
<code class="docutils literal notranslate"><span class="pre">Y</span></code>, and <code class="docutils literal notranslate"><span class="pre">Z</span></code>. If your values are incorrect, your attack might not
work. In your report, you need to describe how you decide the values for
X, Y and Z. Either show us your reasoning or, if you use a
trial-and-error approach, show your trials.</p>
<p><strong>A note regarding ``gdb``.</strong> If you use <code class="docutils literal notranslate"><span class="pre">gdb</span></code> to figure out the values for <code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">Y</span></code>, and <code class="docutils literal notranslate"><span class="pre">Z</span></code>,
it should be noted that the <code class="docutils literal notranslate"><span class="pre">gdb</span></code> behavior in Ubuntu 20.04 is slightly
different from that in Ubuntu 16.04. In particular, after we set a break
point at function <code class="docutils literal notranslate"><span class="pre">bof</span></code>, when <code class="docutils literal notranslate"><span class="pre">gdb</span></code> stops inside the <code class="docutils literal notranslate"><span class="pre">bof()</span></code>
function, it stops before the <code class="docutils literal notranslate"><span class="pre">ebp</span></code> register is set to point to the
current stack frame, so if we print out the value of <code class="docutils literal notranslate"><span class="pre">ebp</span></code> here, we
will get the caller’s <code class="docutils literal notranslate"><span class="pre">ebp</span></code> value, not <code class="docutils literal notranslate"><span class="pre">bof</span></code>’s <code class="docutils literal notranslate"><span class="pre">ebp</span></code>. We need to
type <code class="docutils literal notranslate"><span class="pre">next</span></code> to execute a few instructions and stop after the <code class="docutils literal notranslate"><span class="pre">ebp</span></code>
register is modified to point to the stack frame of the <code class="docutils literal notranslate"><span class="pre">bof()</span></code>
function. The SEED book (2nd edition) is based on Ubuntu 16.04, so it
does not have this <code class="docutils literal notranslate"><span class="pre">next</span></code> step.</p>
<div class="section" id="attack-variation-1">
<h3>Attack variation 1:<a class="headerlink" href="#attack-variation-1" title="Permalink to this headline">¶</a></h3>
<p>Is the <code class="docutils literal notranslate"><span class="pre">exit()</span></code> function really necessary? Please try your attack
without including the address of this function in <code class="docutils literal notranslate"><span class="pre">badfile</span></code>. Run your
attack again, report and explain your observations.</p>
</div>
<div class="section" id="attack-variation-2">
<h3>Attack variation 2:<a class="headerlink" href="#attack-variation-2" title="Permalink to this headline">¶</a></h3>
<p>After your attack is successful, change the file name of <code class="docutils literal notranslate"><span class="pre">retlib</span></code> to a
different name, making sure that the length of the new file name is
different. For example, you can change it to <code class="docutils literal notranslate"><span class="pre">newretlib</span></code>. Repeat the
attack (without changing the content of badfile). Will your attack
succeed or not? If it does not succeed, explain why.</p>
</div>
</div>
<div class="section" id="task-4-defeat-shells-countermeasure">
<h2>Task 4: Defeat Shell’s countermeasure<a class="headerlink" href="#task-4-defeat-shells-countermeasure" title="Permalink to this headline">¶</a></h2>
<p>The purpose of this task is to launch the return-to-libc attack after
the shell’s countermeasure is enabled. Before doing Tasks 1 to 3, we
relinked <code class="docutils literal notranslate"><span class="pre">/bin/sh</span></code> to <code class="docutils literal notranslate"><span class="pre">/bin/zsh</span></code>, instead of to <code class="docutils literal notranslate"><span class="pre">/bin/dash</span></code> (the
original setting). This is because some shell programs, such as <code class="docutils literal notranslate"><span class="pre">dash</span></code>
and <code class="docutils literal notranslate"><span class="pre">bash</span></code>, have a countermeasure that automatically drops privileges
when they are executed in a process. In this task, we would like to
defeat such a countermeasure, i.e., we would like to get a root shell
even though the <code class="docutils literal notranslate"><span class="pre">/bin/sh</span></code> still points to <code class="docutils literal notranslate"><span class="pre">/bin/dash</span></code>. Let us first
change the symbolic link back:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo ln -sf /bin/dash /bin/sh
</pre></div>
</div>
<p>Although <code class="docutils literal notranslate"><span class="pre">dash</span></code> and <code class="docutils literal notranslate"><span class="pre">bash</span></code> both drop the privilege, they will not do
that if they are invoked with the <code class="docutils literal notranslate"><span class="pre">-p</span></code> option. When we return to the
<code class="docutils literal notranslate"><span class="pre">system</span></code> function, this function invokes <code class="docutils literal notranslate"><span class="pre">/bin/sh</span></code>, but it does not
use the <code class="docutils literal notranslate"><span class="pre">-p</span></code> option. Therefore, the privilege of the target program
will be dropped. If there is a function that allows us to directly
execute <code class="docutils literal notranslate"><span class="pre">&quot;/bin/bash</span> <span class="pre">-p&quot;</span></code>, without going through the <code class="docutils literal notranslate"><span class="pre">system</span></code>
function, we can still get the root privilege.</p>
<p>There are actually many libc functions that can do that, such as the
<code class="docutils literal notranslate"><span class="pre">exec()</span></code> family of functions, including <code class="docutils literal notranslate"><span class="pre">execl()</span></code>, <code class="docutils literal notranslate"><span class="pre">execle()</span></code>,
<code class="docutils literal notranslate"><span class="pre">execv()</span></code>, etc. Let’s take a look at the <code class="docutils literal notranslate"><span class="pre">execv()</span></code> function.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int execv(const char *pathname, char *const argv[]);
</pre></div>
</div>
<p>This function takes two arguments, one is the address to the command,
the second is the address to the argument array for the command. For
example, if we want to invoke <code class="docutils literal notranslate"><span class="pre">&quot;/bin/bash</span> <span class="pre">-p&quot;</span></code> using <code class="docutils literal notranslate"><span class="pre">execv</span></code>, we
need to set up the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pathname = address of &quot;/bin/bash&quot;
argv[0]  = address of &quot;/bin/bash&quot;
argv[1]  = address of &quot;-p&quot;
argv[2]  = NULL (i.e., 4 bytes of zero).
</pre></div>
</div>
<p>From the previous tasks, we can easily get the address of the two
involved strings. Therefore, if we can construct the <code class="docutils literal notranslate"><span class="pre">argv[]</span></code> array on
the stack, get its address, we will have everything that we need to
conduct the return-to-libc attack. This time, we will return to the
<code class="docutils literal notranslate"><span class="pre">execv()</span></code> function.</p>
<p>There is one catch here. The value of <code class="docutils literal notranslate"><span class="pre">argv[2]</span></code> must be zero (an
integer zero, four bytes). If we put four zeros in our input,
<code class="docutils literal notranslate"><span class="pre">strcpy()</span></code> will terminate at the first zero; whatever is after that
will not be copied into the <code class="docutils literal notranslate"><span class="pre">bof()</span></code> function’s buffer. This seems to
be a problem, but keep in mind, everything in your input is already on
the stack; they are in the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function’s buffer. It is not hard
to get the address of this buffer. To simplify the task, we already let
the vulnerable program print out that address for you.</p>
<p>Just like in Task 3, you need to construct your input, so when the
<code class="docutils literal notranslate"><span class="pre">bof()</span></code> function returns, it returns to <code class="docutils literal notranslate"><span class="pre">execv()</span></code>, which fetches
from the stack the address of the <code class="docutils literal notranslate"><span class="pre">&quot;/bin/bash&quot;</span></code> string and the address
of the <code class="docutils literal notranslate"><span class="pre">argv[]</span></code> array. You need to prepare everything on the stack, so
when <code class="docutils literal notranslate"><span class="pre">execv()</span></code> gets executed, it can execute <code class="docutils literal notranslate"><span class="pre">&quot;/bin/bash</span> <span class="pre">-p&quot;</span></code> and
give you the root shell. In your report, please describe how you
construct your input.</p>
</div>
<div class="section" id="task-5-optional-return-oriented-programming">
<h2>Task 5 (Optional): Return-Oriented Programming<a class="headerlink" href="#task-5-optional-return-oriented-programming" title="Permalink to this headline">¶</a></h2>
<p>There are many ways to solve the problem in Task 4. Another way is to
invoke <code class="docutils literal notranslate"><span class="pre">setuid(0)</span></code> before invoking <code class="docutils literal notranslate"><span class="pre">system()</span></code>. The <code class="docutils literal notranslate"><span class="pre">setuid(0)</span></code>
call sets both real user ID and effective user ID to 0, turning the
process into a non-one (it still has the root privilege). This approach
requires us to chain two functions together. The approach was
generalized to chaining multiple functions together, and was further
generalized to chain multiple pieces of code together. This led to the
Return-Oriented Programming (ROP).</p>
<p>Using ROP to solve the problem in Task 4 is quite sophisticated, and it
is beyond the scope of this lab. However, we do want to give students a
taste of ROP, asking them to work on a special case of ROP. In the
<code class="docutils literal notranslate"><span class="pre">retlib.c</span></code> program, there is a function called <code class="docutils literal notranslate"><span class="pre">foo()</span></code>, which is
never called in the program. That function is intended for this task.
Your job is to exploit the buffer-overflow problem in the program, so
when the program returns from the <code class="docutils literal notranslate"><span class="pre">bof()</span></code> function, it invokes
<code class="docutils literal notranslate"><span class="pre">foo()</span></code> 10 times, before giving you the root shell. In your lab
report, you need to describe how your input is constructed. Here is what
the results will look like.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./retlib
...
Function foo() is invoked 1 times
Function foo() is invoked 2 times
Function foo() is invoked 3 times
Function foo() is invoked 4 times
Function foo() is invoked 5 times
Function foo() is invoked 6 times
Function foo() is invoked 7 times
Function foo() is invoked 8 times
Function foo() is invoked 9 times
Function foo() is invoked 10 times
bash-5.0#   &lt;-- Got root shell!
</pre></div>
</div>
<p><strong>Guidelines.</strong> Let’s review what we did in Task 3. We constructed the data on the
stack, such that when the program returns from <code class="docutils literal notranslate"><span class="pre">bof()</span></code>, it jumps to
the <code class="docutils literal notranslate"><span class="pre">system()</span></code> function, and when <code class="docutils literal notranslate"><span class="pre">system()</span></code> returns, the program
jumps to the <code class="docutils literal notranslate"><span class="pre">exit()</span></code> function. We will use a similar strategy here.
Instead of jumping to <code class="docutils literal notranslate"><span class="pre">system()</span></code> and <code class="docutils literal notranslate"><span class="pre">exit()</span></code>, we will construct the
data on the stack, such that when the program returns from <code class="docutils literal notranslate"><span class="pre">bof</span></code>, it
returns to <code class="docutils literal notranslate"><span class="pre">foo</span></code>; when <code class="docutils literal notranslate"><span class="pre">foo</span></code> returns, it returns to another <code class="docutils literal notranslate"><span class="pre">foo</span></code>.
This is repeated for 10 times. When the 10th <code class="docutils literal notranslate"><span class="pre">foo</span></code> returns, it returns
to the <code class="docutils literal notranslate"><span class="pre">execv()</span></code> function to give us the root shell.</p>
<p><strong>Further readings.</strong> What we did in this task is just a special case of ROP. You may have
noticed that the <code class="docutils literal notranslate"><span class="pre">foo()</span></code> function does not take any argument. If it
does, invoking it 10 times will become signficantly more complicated. A
generic ROP technique allows you to invoke any number of functions in a
sequence, allowing each function to have multiple arguments. The SEED
book (2nd edition) provides detailed instructions on how to use the
generic ROP technique to solve the problem in Task 4. It involves
calling <code class="docutils literal notranslate"><span class="pre">sprintf()</span></code> four times, followed by an invocation of
<code class="docutils literal notranslate"><span class="pre">setuid(0)</span></code>, before invoking <code class="docutils literal notranslate"><span class="pre">system(&quot;/bin/sh&quot;)</span></code> to give us the root
shell. The method is quite complicated and takes 15 pages to explain in
the SEED book.</p>
</div>
<div class="section" id="guidelines-understanding-the-function-call-mechanism">
<h2>Guidelines: Understanding the Function Call Mechanism<a class="headerlink" href="#guidelines-understanding-the-function-call-mechanism" title="Permalink to this headline">¶</a></h2>
<div class="section" id="understanding-the-stack-layout">
<h3>Understanding the stack layout<a class="headerlink" href="#understanding-the-stack-layout" title="Permalink to this headline">¶</a></h3>
<p>To know how to conduct Return-to-libc attacks, we need to understand how
stacks work. We use a small C program to understand the effects of a
function invocation on the stack. More detailed explanation can be found
in the SEED book and SEED lecture.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* foobar.c */
#include&lt;stdio.h&gt;
void foo(int x)
{
  printf(&quot;Hello world: %d\n&quot;, x);
}

int main()
{
  foo(1);
  return 0;
}
</pre></div>
</div>
<p>We can use “gcc -m32 -S foobar.c” to compile this program to the
assembly code. The resulting file foobar.s will look like the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>   ......
 8 foo:
 9         pushl   %ebp
10         movl    %esp, %ebp
11         subl    $8, %esp
12         movl    8(%ebp), %eax
13         movl    %eax, 4(%esp)
14         movl    $.LC0, (%esp)  : string &quot;Hello world: %d\n&quot;
15         call    printf
16         leave
17         ret
   ......
21 main:
22         leal    4(%esp), %ecx
23         andl    $-16, %esp
24         pushl   -4(%ecx)
25         pushl   %ebp
26         movl    %esp, %ebp
27         pushl   %ecx
28         subl    $4, %esp
29         movl    $1, (%esp)
30         call    foo
31         movl    $0, %eax
32         addl    $4, %esp
33         popl    %ecx
34         popl    %ebp
35         leal    -4(%ecx), %esp
36         ret
</pre></div>
</div>
</div>
<div class="section" id="calling-and-entering-foo">
<h3>Calling and entering foo()<a class="headerlink" href="#calling-and-entering-foo" title="Permalink to this headline">¶</a></h3>
<p>Let us concentrate on the stack while calling foo(). We can ignore the
stack before that. Please note that line numbers instead of instruction
addresses are used in this explanation.</p>
<div class="align-center figure align-default" id="id1">
<img alt="center" src="../../_images/software_img1.png" />
<p class="caption"><span class="caption-text">Figure 1: Entering and Leaving <code class="docutils literal notranslate"><span class="pre">foo()</span></code></span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<ul class="simple">
<li><p><strong>Line 28-29:</strong>: These two statements push the value <span class="math notranslate nohighlight">\(1\)</span>, i.e.
the argument to the foo(), into the stack. This operation increments
%esp by four. The stack after these two statements is depicted in
Figure 1(a).</p></li>
<li><p><strong>Line 30: ``call foo``</strong>: The statement pushes the address of the
next instruction that immediately follows the call statement into the
stack (i.e the return address), and then jumps to the code of foo().
The current stack is depicted in
Figure 1(b).</p></li>
<li><p><strong>Line 9-10</strong>: The first line of the function foo() pushes %ebp into
the stack, to save the previous frame pointer. The second line lets
%ebp point to the current frame. The current stack is depicted in
Figure 1(c).</p></li>
<li><p><strong>Line 11: ``subl $8, %esp``</strong>: The stack pointer is modified to
allocate space (8 bytes) for local variables and the two arguments
passed to printf. Since there is no local variable in function foo,
the 8 bytes are for arguments only. See
Figure 1(d).</p></li>
</ul>
</div>
<div class="section" id="leaving-foo">
<h3>Leaving foo()<a class="headerlink" href="#leaving-foo" title="Permalink to this headline">¶</a></h3>
<p>Now the control has passed to the function foo(). Let us see what
happens to the stack when the function returns.</p>
<ul>
<li><p><strong>Line 16: ``leave``</strong>: This instruction implicitly performs two
instructions (it was a macro in earlier x86 releases, but was made
into an instruction later):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mov  %ebp, %esp
pop  %ebp
</pre></div>
</div>
<p>The first statement releases the stack space allocated for the
function; the second statement recovers the previous frame pointer.
The current stack is depicted in
Figure 1(e).</p>
</li>
<li><p><strong>Line 17: ``ret``</strong>: This instruction simply pops the return address
out of the stack, and then jump to the return address. The current
stack is depicted in
Figure 1(f).</p></li>
<li><p><strong>Line 32: ``addl $4, %esp``</strong>: Further restore the stack by
releasing more memories allocated for foo. As you can see that the
stack is now in exactly the same state as it was before entering the
function foo (i.e., before line 28).</p></li>
</ul>
</div>
</div>
<div class="section" id="submission">
<h2>Submission<a class="headerlink" href="#submission" title="Permalink to this headline">¶</a></h2>
<p>You need to submit a detailed lab report, with screenshots, to describe what you have done and what you
have observed. You also need to provide explanation to the observations that are interesting or surprising.
Please also list the important code snippets followed by explanation. Simply attaching code without any
explanation will not receive credits</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Environment_Variable_and_SetUID.html" class="btn btn-neutral float-right" title="Environment Variable and Program Lab" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="Buffer_Overflow_Server.html" class="btn btn-neutral float-left" title="Buffer Overflow Attack Lab (Server Version)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, NEXUS Lab.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>