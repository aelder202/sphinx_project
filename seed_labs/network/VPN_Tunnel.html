

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>VPN Lab: The Container Version &mdash; Network Security Lab  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Web Security Labs" href="../web/web_index.html" />
    <link rel="prev" title="Virtual Private Network (VPN) Lab" href="VPN.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Network Security Lab
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../xie/xie_labs.html">Xie Labs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../seed_index.html">SEED Labs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../crypto/crypto_index.html">Cryptography Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hardware/hardware_index.html">Hardware Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mobile/mobile_index.html">Mobile Security Labs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="network_index.html">Network Security Labs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="arp_attack.html">ARP Cache Poisoning Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="bgp_basic.html">BGP Lab: Building an Internet Simulator</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_in_a_box.html">DNS In a Box</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_local.html">Local DNS Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_rebinding.html">DNS Rebinding Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_remote.html">The Kaminsky Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="dnssec.html">DNS Security Extensions (DNSSEC) Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="firewall.html">Firewall Exploration Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="firewall_vpn.html">Firewall Evasion Lab: Bypassing Firewalls using VPN</a></li>
<li class="toctree-l3"><a class="reference internal" href="Heartbleed.html">Heartbleed Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="ICMP_Redirect.html">ICMP Redirect Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Mitnick_Attack.html">The Mitnick Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Sniffing_Spoofing.html">Packet Sniffing and Spoofing Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="TCP_Attacks.html">TCP/IP Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="VPN.html">Virtual Private Network (VPN) Lab</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">VPN Lab: The Container Version</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-1-network-setup">Task 1: Network Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-2-create-and-configure-tun-interface">Task 2: Create and Configure TUN Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-3-send-the-ip-packet-to-vpn-server-through-a-tunnel">Task 3: Send the IP Packet to VPN Server Through a Tunnel</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-4-set-up-the-vpn-server">Task 4: Set Up the VPN Server</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-5-handling-traffic-in-both-directions">Task 5: Handling Traffic in Both Directions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-6-tunnel-breaking-experiment">Task 6: Tunnel-Breaking Experiment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-7-routing-experiment-on-host-v">Task 7: Routing Experiment on Host V</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-8-vpn-between-private-networks">Task 8: VPN Between Private Networks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-9-experiment-with-the-tap-interface">Task 9: Experiment with the TAP Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#submission">Submission</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../web/web_index.html">Web Security Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../software/software_index.html">Software Security Labs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../website_link/web_index.html"><strong>Return To Website</strong></a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Network Security Lab</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../seed_index.html">SEED Labs</a> &raquo;</li>
        
          <li><a href="network_index.html">Network Security Labs</a> &raquo;</li>
        
      <li>VPN Lab: The Container Version</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="vpn-lab-the-container-version">
<h1>VPN Lab: The Container Version<a class="headerlink" href="#vpn-lab-the-container-version" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>A Virtual Private Network (VPN) is a private network built on top of a
public network, usually the Internet. Computers inside a VPN can
communicate securely, just like if they were on a real private network
that is physically isolated from outside, even though their traffic may
go through a public network. VPN enables employees to securely access a
company’s intranet while traveling; it also allows companies to expand
their private networks to places across the country and around the
world.</p>
<p>The objective of this lab is to help students understand how VPN works.
We focus on a specific type of VPN (the most common type), which is
built on top of the transport layer. We will build a very simple VPN
from the scratch, and use the process to illustrate how each piece of
the VPN technology works. A real VPN program has two essential pieces,
tunneling and encryption. This lab only focuses on the tunneling part,
helping students understand the tunneling technology, so the tunnel in
this lab is not encrypted. There is another more comprehensive VPN lab
that includes the encryption part. The lab covers the following topics:</p>
<ul class="simple">
<li>Virtual Private Network</li>
<li>The TUN/TAP virtual interface</li>
<li>IP tunneling</li>
<li>Routing</li>
</ul>
<p><strong>Readings and videos.</strong> Detailed coverage of the TUN/TAP virtual interface and how VPN works can
be found in the following:</p>
<ul class="simple">
<li>Chapter 19 of the SEED Book, Computer &amp; Internet Security: A Hands-on Approach, 2nd Edition,
by Wenliang Du. See details at <a class="reference external" href="https://www.handsonsecurity.net">https://www.handsonsecurity.net</a>.</li>
<li>Section 8 of the SEED Lecture, Internet Security: A Hands-on Approach, by Wenliang Du. See details
at <a class="reference external" href="https://www.handsonsecurity.net/video.html">https://www.handsonsecurity.net/video.html</a>.</li>
</ul>
<p><strong>Related lab.</strong> This lab only covers the tunneling part of a VPN, while a complete VPN
also needs to protect its tunnel. We have a separate lab, called VPN
Lab, which is a comprehensive lab, covering both tunneling and the
protection part. Students can work on this tunneling lab first. After
learning the PKI and TLS, they can then move on to the comprehensive VPN
lab.</p>
<p><strong>Lab environment.</strong> This lab has been tested on the SEED Ubuntu 20.04 VM. You can download a pre-built
image from the SEED website, and run the SEED VM on your own computer. However, most of the SEED
labs can be conducted on the cloud, and you can follow our instruction to create a SEED VM on the cloud.</p>
</div>
<div class="section" id="task-1-network-setup">
<h2>Task 1: Network Setup<a class="headerlink" href="#task-1-network-setup" title="Permalink to this headline">¶</a></h2>
<p>We will create a VPN tunnel between a computer (client) and a gateway,
allowing the computer to securely access a private network via the
gateway. We need at least three machines: VPN client (also serving as
Host U), VPN server (the router/gateway), and a host in the private
network (Host V). The network setup is depicted in
Figure&nbsp;1.</p>
<div class="figure align-center" id="id1">
<img alt="../../_images/vpn_tunnel_img1.png" src="../../_images/vpn_tunnel_img1.png" />
<p class="caption"><span class="caption-text">Figure 1: Lab environment setup</span></p>
</div>
<p>In practice, the VPN client and VPN server are connected via the
Internet. For the sake of simplicity, we directly connect these two
machines to the same LAN in this lab, i.e., this LAN simulates the
Internet.</p>
<p>The third machine, Host V, is a computer inside the private network.
Users on Host U(outside of the private network) want to communicate with
Host V via the VPN tunnel. To simulate this setup, we connect Host V to
VPN Server (also serving as a gateway). In such a setup, Host V is not
directly accessible from the Internet; nor is it directly accessible
from Host U.</p>
<p><strong>Lab setup.</strong> Please download the <code class="docutils literal notranslate"><span class="pre">Labsetup.zip</span></code> file to your VM from the lab’s website, unzip it, enter the <code class="docutils literal notranslate"><span class="pre">Labsetup</span></code>
folder, and use the <code class="docutils literal notranslate"><span class="pre">docker-compose.yml</span></code> file to set up the lab environment. Detailed explanation of the
content in this file and all the involved <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> can be found from the user manual, which is linked
to the website of this lab. If this is the first time you set up a SEED lab environment using containers, it is
very important that you read the user manual.</p>
<p>In the following, we list some of the commonly used commands related to Docker and Compose. Since
we are going to use these commands very frequently, we have created aliases for them in the <code class="docutils literal notranslate"><span class="pre">.bashrc</span></code> file
(in our provided SEEDUbuntu 20.04 VM).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker-compose build    # Build the container image
$ docker-compose up       # Start the container
$ docker-compose down     # Shut down the container

// Aliases for the Compose commands above
$ dcbuild                 # Alias for: docker-compose build
$ dcup                    # Alias for: docker-compose up
$ dcdown                  # Alias for: docker-compose down
</pre></div>
</div>
<p>All the containers will be running in the background. To run commands on a container, we often need
to get a shell on that container. We first need to use the “<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">ps</span></code>” command to find out the ID of
the container, and then use “<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">exec</span></code>” to start a shell on that container. We have created aliases for
them in the <code class="docutils literal notranslate"><span class="pre">.bashrc</span></code> file.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ dockps        // Alias for: docker ps --format &quot;{{.ID}} {{.Names}}&quot;
$ docksh &lt;id&gt;   // Alias for: docker exec -it &lt;id&gt; /bin/bash

// The following example shows how to get a shell inside hostC
$ dockps
b1004832e275 hostA-10.9.0.5
0af4ea7a3e2e hostB-10.9.0.6
9652715c8e0a hostC-10.9.0.7

$ docksh 96
root@9652715c8e0a:/#

// Note: If a docker command requires a container ID, you do not need to
//       type the entire ID string. Typing the first few characters will
//       be sufficient, as long as they are unique among all the containers.
</pre></div>
</div>
<p>If you encounter problems when setting up the lab environment, please read the “Common Problems”
section of the manual for potential solutions.</p>
<p><strong>Shared folder.</strong> In this lab, we need to write our own code and run it inside containers.
Code editing is more convenient inside the VM than in containers, because we can use our favorite editors. In order for the
VM and container to share files, we have created a shared folder between the VM and the container using
the Docker <code class="docutils literal notranslate"><span class="pre">volumes</span></code>. If you look at the Docker Compose file, you will find out that we have added the
following entry to some of the containers. It indicates mounting the <code class="docutils literal notranslate"><span class="pre">./volumes</span></code> folder on the host machine
(i.e., the VM) to the <code class="docutils literal notranslate"><span class="pre">/volumes</span></code> folder inside the container. We will write our code in the <code class="docutils literal notranslate"><span class="pre">./volumes</span></code>
folder (on the VM), so they can be used inside the containers.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>volumes:
    ./volumes:/volumes
</pre></div>
</div>
<p><strong>Packet sniffing.</strong> Being able to sniffing packets is very important in
this lab, because if things do not go as expected, being able to look at
where packets go can help us identify the problems. There are several
different ways to do packet sniffing:</p>
<ul>
<li><p class="first">Running <code class="docutils literal notranslate"><span class="pre">tcpdump</span></code> on containers. We have already installed <code class="docutils literal notranslate"><span class="pre">tcpdump</span></code> on each container. To sniff
the packets going through a particular interface, we just need to find out the interface name, and then
do the following (assume that the interface name is <code class="docutils literal notranslate"><span class="pre">eth0</span></code>):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># tcpdump -i eth0 -n
</pre></div>
</div>
<p>It should be noted that inside containers, due to the isolation created by Docker, when we run
<code class="docutils literal notranslate"><span class="pre">tcpdump</span></code> inside a container, we can only sniff the packets going in and out of this container. We
won’t be able to sniff the packets between other containers. However, if a container uses the host
mode in its network setup, it can sniff other containers’ packets.</p>
</li>
<li><p class="first">Running <code class="docutils literal notranslate"><span class="pre">tcpdump</span></code> on the VM. If we run <code class="docutils literal notranslate"><span class="pre">tcpdump</span></code> on the VM, we do not have the restriction on the
containers, and we can sniff all the packets going among containers. The interface name for a network
is different on the VM than on the container. On containers, each interface name usually starts with
<code class="docutils literal notranslate"><span class="pre">eth</span></code>; on the VM, the interface name for the network created by Docker starts with <code class="docutils literal notranslate"><span class="pre">br-</span></code>, followed by
the ID of the network. You can always use the <code class="docutils literal notranslate"><span class="pre">ip</span> <span class="pre">address</span></code> command to get the interface name on
the VM and containers.</p>
</li>
<li><p class="first">We can also run Wireshark on the VM to sniff packets. Similar to tcpdump, we need to select what
interface we want Wireshark to sniff on.</p>
</li>
</ul>
<p><strong>Testing.</strong> Please conduct the following testings to ensure that the lab environment
is set up correctly:</p>
<ul class="simple">
<li>Host U can communicate with VPN Server.</li>
<li>VPN Server can communicate with Host V.</li>
<li>Host U should not be able to communicate with Host V.</li>
<li>Run <code class="docutils literal notranslate"><span class="pre">tcpdump</span></code> on the router, and sniff the traffic on each of the
network. Show that you can capture packets.</li>
</ul>
</div>
<div class="section" id="task-2-create-and-configure-tun-interface">
<h2>Task 2: Create and Configure TUN Interface<a class="headerlink" href="#task-2-create-and-configure-tun-interface" title="Permalink to this headline">¶</a></h2>
<p>The VPN tunnel that we are going to build is based on the TUN/TAP
technologies. TUN and TAP are virtual network kernel drivers; they
implement network device that are supported entirely in software. TAP
(as in network tap) simulates an Ethernet device and it operates with
layer-2 packets such as Ethernet frames; TUN (as in network TUNnel)
simulates a network layer device and it operates with layer-3 packets
such as IP packets. With TUN/TAP, we can create virtual network
interfaces.</p>
<p>A user-space program is usually attached to the TUN/TAP virtual network
interface. Packets sent by an operating system via a TUN/TAP network
interface are delivered to the user-space program. On the other hand,
packets sent by the program via a TUN/TAP network interface are injected
into the operating system network stack. To the operating system, it
appears that the packets come from an external source through the
virtual network interface.</p>
<p>When a program is attached to a TUN/TAP interface, IP packets sent by
the kernel to this interface will be piped into the program. On the
other hand, IP packets written to the interface by the program will be
piped into the kernel, as if they came from the outside through this
virtual network interface. The program can use the standard read() and
write() system calls to receive packets from or send packets to the
virtual interface.</p>
<p>The objective of this task is to get familiar with the TUN/TAP
technology. We will conduct several experiments to learn the technical
details of the TUN/TAP interface. We will use the following Python
program as the basis for the experiments, and we will modify this base
code throughout this lab. The code is already included in the
<code class="docutils literal notranslate"><span class="pre">volumes</span></code> folder in the zip file. Below is Listing 1: Creating a TUN
interface (<code class="docutils literal notranslate"><span class="pre">tun.py</span></code>).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env python3

import fcntl
import struct
import os
import time
from scapy.all import *

TUNSETIFF = 0x400454ca
IFF_TUN   = 0x0001
IFF_TAP   = 0x0002
IFF_NO_PI = 0x1000

# Create the tun interface
tun = os.open(&quot;/dev/net/tun&quot;, os.O_RDWR)
ifr = struct.pack(&#39;16sH&#39;, b&#39;tun%d&#39;, IFF_TUN | IFF_NO_PI)
ifname_bytes  = fcntl.ioctl(tun, TUNSETIFF, ifr)

# Get the interface name
ifname = ifname_bytes.decode(&#39;UTF-8&#39;)[:16].strip(&quot;\x00&quot;)
print(&quot;Interface Name: {}&quot;.format(ifname))

while True:
   time.sleep(10)
</pre></div>
</div>
<div class="section" id="task-2-a-name-of-the-interface">
<h3>Task 2.a: Name of the Interface<a class="headerlink" href="#task-2-a-name-of-the-interface" title="Permalink to this headline">¶</a></h3>
<p>We will run the <code class="docutils literal notranslate"><span class="pre">tun.py</span></code> program on Host U. Make the above <code class="docutils literal notranslate"><span class="pre">tun.py</span></code>
program executable, and run it using the root privilege. See the
following commands:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Make the Python program executable
# chmod a+x tun.py

// Run the program using the root privilege
# tun.py
</pre></div>
</div>
<p>Once the program is executed, it will block. You can go to another
terminal and get a new shell on the container. Then print out all the
interfaces on the machine. Please report your observation after running
the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># ip address
</pre></div>
</div>
<p>You should be able to find an interface called <code class="docutils literal notranslate"><span class="pre">tun0</span></code>. Your job in
this task is to change the <code class="docutils literal notranslate"><span class="pre">tun.py</span></code> program, so instead of using
<code class="docutils literal notranslate"><span class="pre">tun</span></code> as the prefix of the interface name, use your last name as the
prefix. For example, if your last name is smith, you should use
<code class="docutils literal notranslate"><span class="pre">smith</span></code> as the prefix. If your last name is long, you can use the
first five characters. Please show your results.</p>
</div>
<div class="section" id="task-2-b-set-up-the-tun-interface">
<h3>Task 2.b: Set up the TUN Interface<a class="headerlink" href="#task-2-b-set-up-the-tun-interface" title="Permalink to this headline">¶</a></h3>
<p>At this point, the TUN interface is not usable, because it has not been
configured yet. There are two things that we need to do before the
interface can be used. First, we need to assign an IP address to it.
Second, we need to bring up the interface, because the interface is
still in the down state. We can use the following two commands for the
configuration:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Assign IP address to the interface
# ip addr add 192.168.53.99/24 dev tun0

// Bring up the interface
# ip link set dev tun0 up
</pre></div>
</div>
<p>To make life easier, students can add the following two lines of code to
<code class="docutils literal notranslate"><span class="pre">tun.py</span></code>, so the configuration can be automatically performed by the
program.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>os.system(&quot;ip addr add 192.168.53.99/24 dev {}&quot;.format(ifname))
os.system(&quot;ip link set dev {} up&quot;.format(ifname))
</pre></div>
</div>
<p>After running the two commands above, run the <code class="docutils literal notranslate"><span class="pre">&quot;ip</span> <span class="pre">address&quot;</span></code> command
again, and report your observation. How is it different from that before
running the configuration commands?</p>
</div>
<div class="section" id="task-2-c-read-from-the-tun-interface">
<h3>Task 2.c: Read from the TUN Interface<a class="headerlink" href="#task-2-c-read-from-the-tun-interface" title="Permalink to this headline">¶</a></h3>
<p>In this task, we will read from the TUN interface. Whatever coming out
from the TUN interface is an IP packet. We can cast the data received
from the interface into a Scapy <code class="docutils literal notranslate"><span class="pre">IP</span></code> object, so we can print out each
field of the IP packet. Please use the following <code class="docutils literal notranslate"><span class="pre">while</span></code> loop to
replace the one in <code class="docutils literal notranslate"><span class="pre">tun.py</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>while True:
   # Get a packet from the tun interface
   packet = os.read(tun, 2048)
   if packet:
      ip = IP(packet)
      print(ip.summary())
</pre></div>
</div>
<p>Please run the revised <code class="docutils literal notranslate"><span class="pre">tun.py</span></code> program on Host U, configure the TUN
interface accordingly, and then conduct the following experiments.
Please describe your observations:</p>
<ul class="simple">
<li>On Host U, <code class="docutils literal notranslate"><span class="pre">ping</span></code> a host in the <code class="docutils literal notranslate"><span class="pre">192.168.53.0/24</span></code> network. What
are printed out by the <code class="docutils literal notranslate"><span class="pre">tun.py</span></code> program? What has happened? Why?</li>
<li>On Host U, <code class="docutils literal notranslate"><span class="pre">ping</span></code> a host in the internal network
<code class="docutils literal notranslate"><span class="pre">192.168.60.0/24</span></code>, Does <code class="docutils literal notranslate"><span class="pre">tun.py</span></code> print out anything? Why?</li>
</ul>
</div>
<div class="section" id="task-2-d-write-to-the-tun-interface">
<h3>Task 2.d: Write to the TUN Interface<a class="headerlink" href="#task-2-d-write-to-the-tun-interface" title="Permalink to this headline">¶</a></h3>
<p>In this task, we will write to the TUN interface. Since this is a
virtual network interface, whatever is written to the interface by the
application will appear in the kernel as an IP packet.</p>
<p>We will modify the <code class="docutils literal notranslate"><span class="pre">tun.py</span></code> program, so after getting a packet from
the TUN interface, we construct a new packet based on the received
packet. We then write the new packet to the TUN interface. How the new
packet is constructed is up to students. The code in the following shows
an example of how to write an IP packet to the TUN interface.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Send out a spoof packet using the tun interface
newip  = IP(src=&#39;1.2.3.4&#39;, dst=ip.src)
newpkt = newip/ip.payload
os.write(tun, bytes(newpkt))
</pre></div>
</div>
<p>Please modify the <code class="docutils literal notranslate"><span class="pre">tun.py</span></code> code according to the following
requirements:</p>
<ul class="simple">
<li>After getting a packet from the TUN interface, if this packet is an
ICMP echo request packet, construct a corresponding echo reply packet
and write it to the TUN interface. Please provide evidence to show
that the code works as expected.</li>
<li>Instead of writing an IP packet to the interface, write some
arbitrary data to the interface, and report your observation.</li>
</ul>
</div>
</div>
<div class="section" id="task-3-send-the-ip-packet-to-vpn-server-through-a-tunnel">
<h2>Task 3: Send the IP Packet to VPN Server Through a Tunnel<a class="headerlink" href="#task-3-send-the-ip-packet-to-vpn-server-through-a-tunnel" title="Permalink to this headline">¶</a></h2>
<p>In this task, we will put the IP packet received from the TUN interface
into the UDP payload field of a new IP packet, and send it to another
computer. Namely, we place the original packet inside a new packet. This
is called IP tunneling. The tunnel implementation is just standard
client/server programming. It can be built on top of TCP or UDP. In this
task, we will use UDP. Namely, we put an IP packet inside the payload
field of a UDP packet.</p>
<p><strong>The server program ``tun_server.py``.</strong> We will run <code class="docutils literal notranslate"><span class="pre">tun_server.py</span></code> program on VPN Server. This program is
just a standard UDP server program. It listens to port <code class="docutils literal notranslate"><span class="pre">9090</span></code> and
print out whatever is received. The program assumes that the data in the
UDP payload field is an IP packet, so it casts the payload to a Scapy
<code class="docutils literal notranslate"><span class="pre">IP</span></code> object, and print out the source and destination IP address of
the enclosed IP packet. Below is Listing 2: <code class="docutils literal notranslate"><span class="pre">tun.server.py</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env python3

from scapy.all import *

IP_A = &quot;0.0.0.0&quot;
PORT = 9090

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((IP_A, PORT))

while True:
   data, (ip, port) = sock.recvfrom(2048)
   print(&quot;{}:{} --&gt; {}:{}&quot;.format(ip, port, IP_A, PORT))
   pkt = IP(data)
   print(&quot;   Inside: {} --&gt; {}&quot;.format(pkt.src, pkt.dst))
</pre></div>
</div>
<p><strong>Implement the client program tun_client.py.</strong> First, we need to modify
the TUN program <code class="docutils literal notranslate"><span class="pre">tun.py</span></code>. Let’s rename it,
and call it <code class="docutils literal notranslate"><span class="pre">tun_client.py</span></code>. Sending data to another computer using
UDP can be done using the standard socket programming.</p>
<p>Replace the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop in the program with the following: The
<code class="docutils literal notranslate"><span class="pre">SERVER_IP</span></code> and <code class="docutils literal notranslate"><span class="pre">SERVER_PORT</span></code> should be replaced with the actual IP
address and port number of the server program running on VPN Server.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Create UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

while True:
   # Get a packet from the tun interface
   packet = os.read(tun, 2048)
   if packet:
      # Send the packet via the tunnel
      sock.sendto(packet, (SERVER_IP, SERVER_PORT))
</pre></div>
</div>
<p><strong>Testing.</strong> Run the <code class="docutils literal notranslate"><span class="pre">tun_server.py</span></code> program on VPN Server, and then run
<code class="docutils literal notranslate"><span class="pre">tun_client.py</span></code> on Host U. To test whether the tunnel works or not,
<code class="docutils literal notranslate"><span class="pre">ping</span></code> any IP address belonging to the <code class="docutils literal notranslate"><span class="pre">192.168.53.0/24</span></code> network.
What is printed out on VPN Server? Why?</p>
<p>Our ultimate goal is to access the hosts inside the private network
<code class="docutils literal notranslate"><span class="pre">192.168.60.0/24</span></code> using the tunnel. Let us <code class="docutils literal notranslate"><span class="pre">ping</span></code> Host V, and see
whether the ICMP packet is sent to VPN Server through the tunnel. If
not, what are the problems? You need to solve this problem, so the
<code class="docutils literal notranslate"><span class="pre">ping</span></code> packet can be sent through the tunnel. This is done through
routing, i.e., packets going to the <code class="docutils literal notranslate"><span class="pre">192.168.60.0/24</span></code> network should
be routed to the TUN interface and be given to the <code class="docutils literal notranslate"><span class="pre">tun_client.py</span></code>
program. The following command shows how to add an entry to the routing
table:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># ip route add &lt;network&gt; dev &lt;interface&gt; via &lt;router ip&gt;
</pre></div>
</div>
<p>Please provide proofs to demonstrate that when you <code class="docutils literal notranslate"><span class="pre">ping</span></code> an IP
address in the <code class="docutils literal notranslate"><span class="pre">192.168.60.0/24</span></code> network, the ICMP packets are
received by <code class="docutils literal notranslate"><span class="pre">tun_server.py</span></code> through the tunnel.</p>
</div>
<div class="section" id="task-4-set-up-the-vpn-server">
<h2>Task 4: Set Up the VPN Server<a class="headerlink" href="#task-4-set-up-the-vpn-server" title="Permalink to this headline">¶</a></h2>
<p>After <code class="docutils literal notranslate"><span class="pre">tun_server.py</span></code> gets a packet from the tunnel, it needs to feed
the packet to the kernel, so the kernel can route the packet towards its
final destination. This needs to be done through a TUN interface, just
like what we did in Task 2. Please modify <code class="docutils literal notranslate"><span class="pre">tun_server.py</span></code>, so it can
do the following:</p>
<ul class="simple">
<li>Create a TUN interface and configure it.</li>
<li>Get the data from the socket interface; treat the received data as an
IP packet.</li>
<li>Write the packet to the TUN interface.</li>
</ul>
<p>Before running the modified <code class="docutils literal notranslate"><span class="pre">tun_server.py</span></code>, we need to enable the IP
forwarding. Unless specifically configured, a computer will only act as
a host, not as a gateway. VPN Server needs to forward packets between
the private network and the tunnel, so it needs to function as a
gateway. We need to enable the IP forwarding for a computer to behave
like a gateway. IP forwarding has already been enabled on the router
container. You can see in <code class="docutils literal notranslate"><span class="pre">docker-compose.yml</span></code> that the router
container has the following entry:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sysctls:
        - net.ipv4.ip_forward=1
</pre></div>
</div>
<p><strong>Testing.</strong> If everything is set up properly, we can <code class="docutils literal notranslate"><span class="pre">ping</span></code> Host V from Host U.
The ICMP echo request packets should eventually arrive at Host V through
the tunnel. Please show your proof. It should be noted that although
Host V will respond to the ICMP packets, the reply will not get back to
Host U, because we have not set up everything yet. Therefore, for this
task, it is sufficient to show (using Wireshark or tcpdump) that the
ICMP packets have arrived at Host V.</p>
</div>
<div class="section" id="task-5-handling-traffic-in-both-directions">
<h2>Task 5: Handling Traffic in Both Directions<a class="headerlink" href="#task-5-handling-traffic-in-both-directions" title="Permalink to this headline">¶</a></h2>
<p>After getting to this point, one direction of your tunnel is complete,
i.e., we can send packets from Host U to Host V via the tunnel. If we
look at the Wireshark trace on Host V, we can see that Host V has sent
out the response, but the packet gets dropped somewhere. This is because
our tunnel is only one directional; we need to set up its other
direction, so returning traffic can be tunneled back to Host U.</p>
<p>To achieve that, our TUN client and server programs need to read data
from two interfaces, the TUN interface and the socket interface. All
these interfaces are represented by file descriptors, so we need to
monitor them to see whether there are data coming from them. One way to
do that is to keep polling them, and see whether there are data on each
of the interfaces. The performance of this approach is undesirable,
because the process has to keep running in an idle loop when there is no
data. Another way is to read from an interface. By default, read is
blocking, i.e., the process will be suspended if there are no data. When
data become available, the process will be unblocked, and its execution
will continue. This way, it does not waste CPU time when there is no
data.</p>
<p>The read-based blocking mechanism works well for one interface. If a
process is waiting on multiple interfaces, it cannot block on just one
of the interfaces. It has to block on all of them altogether. has a
system call called <code class="docutils literal notranslate"><span class="pre">select()</span></code>, which allows a program to monitor
multiple file descriptors simultaneously. To use <code class="docutils literal notranslate"><span class="pre">select()</span></code>, we need
to store all the file descriptors to be monitored in a set, and then we
give the set to the <code class="docutils literal notranslate"><span class="pre">select()</span></code> system call, which will block the
process until data are available on one of the file descriptors in the
set. We can check which file descriptor has received data. In the
following Python code snippet, we use <code class="docutils literal notranslate"><span class="pre">select()</span></code> to monitor a <code class="docutils literal notranslate"><span class="pre">TUN</span></code>
and a socket file descriptor.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># We assume that sock and tun file descriptors have already been created.

while True:
  # this will block until at least one interface is ready
  ready, _, _ = select.select([sock, tun], [], [])

  for fd in ready:
    if fd is sock:
       data, (ip, port) = sock.recvfrom(2048)
       pkt = IP(data)
       print(&quot;From socket &lt;==: {} --&gt; {}&quot;.format(pkt.src, pkt.dst))
       ... (code needs to be added by students) ...

    if fd is tun:
       packet = os.read(tun, 2048)
       pkt = IP(packet)
       print(&quot;From tun    ==&gt;: {} --&gt; {}&quot;.format(pkt.src, pkt.dst))
       ... (code needs to be added by students) ...
</pre></div>
</div>
<p>Students can use the code above to replace the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop in their
TUN client and server programs. The code is incomplete; students are
expected to complete it.</p>
<p><strong>Testing.</strong> Once this is done, we should be able to communicate with Machine V from
Machine U, and the VPN tunnel (un-encrypted) is now complete. Please
show your wireshark proof using about <code class="docutils literal notranslate"><span class="pre">ping</span></code> and <code class="docutils literal notranslate"><span class="pre">telnet</span></code> commands.
In your proof, you need to point out how your packets flow.</p>
</div>
<div class="section" id="task-6-tunnel-breaking-experiment">
<h2>Task 6: Tunnel-Breaking Experiment<a class="headerlink" href="#task-6-tunnel-breaking-experiment" title="Permalink to this headline">¶</a></h2>
<p>On Host U, <code class="docutils literal notranslate"><span class="pre">telnet</span></code> to Host V. While keeping the <code class="docutils literal notranslate"><span class="pre">telnet</span></code> connection
alive, we break the VPN tunnel by stopping the <code class="docutils literal notranslate"><span class="pre">tun_client.py</span></code> or
<code class="docutils literal notranslate"><span class="pre">tun_server.py</span></code> program. We then type something in the <code class="docutils literal notranslate"><span class="pre">telnet</span></code>
window. Do you see what you type? What happens to the TCP connection? Is
the connection broken?</p>
<p>Let us now reconnect the VPN tunnel (do not wait for too long). We will
run the <code class="docutils literal notranslate"><span class="pre">tun_client.py</span></code> and <code class="docutils literal notranslate"><span class="pre">tun_server.py</span></code> programs again, and set
up their TUN interfaces and routing (this is where you can find that
including the configuration commands in the programs will make your life
much easier). Once the tunnel is re-established, what is going to happen
to the <code class="docutils literal notranslate"><span class="pre">telnet</span></code> connection? Please describe and explain your
observations.</p>
</div>
<div class="section" id="task-7-routing-experiment-on-host-v">
<h2>Task 7: Routing Experiment on Host V<a class="headerlink" href="#task-7-routing-experiment-on-host-v" title="Permalink to this headline">¶</a></h2>
<p>In an real VPN system, the traffic will be encrypted (this part is not
covered in this lab). That means the return traffic must come back from
the same tunnel. How to get the return traffic from Host V to the VPN
server is non-trivial. Our setup simplifies the situation. In our setup,
Host <code class="docutils literal notranslate"><span class="pre">V</span></code>’s routing table has a default setting: packets going to any
destination, except the <code class="docutils literal notranslate"><span class="pre">192.168.60.0/24</span></code> network, will be
automatically routed to the VPN server.</p>
<p>In the real world, Host V may be a few hops away from the VPN server,
and the default routing entry may not guarantee to route the return
packet back to the VPN server. Routing tables inside a private network
have to be set up properly to ensure that packets going to the other end
of the tunnel will be routed to the VPN server. To simulate this
scenario, we will remove the default entry from Host V, and add a more
specific entry to the routing table, so the return packets can be routed
back to the VPN server. Students can use the following commands to
remove the default entry and add a new entry:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Delete the default entry
# ip route del default

// Add an entry
# ip route add &lt;network prefix&gt; via &lt;router ip&gt;
</pre></div>
</div>
</div>
<div class="section" id="task-8-vpn-between-private-networks">
<h2>Task 8: VPN Between Private Networks<a class="headerlink" href="#task-8-vpn-between-private-networks" title="Permalink to this headline">¶</a></h2>
<div class="figure align-center" id="id2">
<img alt="../../_images/vpn_tunnel_img2.png" src="../../_images/vpn_tunnel_img2.png" />
<p class="caption"><span class="caption-text">Figure 2: VPN between two private networks</span></p>
</div>
<p>In this task, we are setting up a VPN between two private networks. The
setup is illustrated in Figure&nbsp;2.
The whole setup is described in the <code class="docutils literal notranslate"><span class="pre">docker-compose2.yml</span></code> file, and
you can use the <code class="docutils literal notranslate"><span class="pre">&quot;-f</span> <span class="pre">docker-compose2.yml&quot;</span></code> option to ask
<code class="docutils literal notranslate"><span class="pre">docker-compose</span></code> to use this file, instead of the default
<code class="docutils literal notranslate"><span class="pre">docker-compose.yml</span></code> file.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker-compose -f docker-compose2.yml build
$ docker-compose -f docker-compose2.yml up
$ docker-compose -f docker-compose2.yml down
</pre></div>
</div>
<p>This setup simulates a situation where an organization has two sites,
each having a private network. The only way to connect these two
networks is through the Internet. Your task is to set up a VPN between
these two sites, so the communication between these two networks will go
through a VPN tunnel. You can use the code developed earlier, but you
need to think about how to set up the correct routing, so packets
between these two private networks can get routed into the VPN tunnel.
In your report, please describe and explain what you did. You need to
provide proofs to show that the packets between the two private networks
are indeed going through a VPN tunnel.</p>
</div>
<div class="section" id="task-9-experiment-with-the-tap-interface">
<h2>Task 9: Experiment with the TAP Interface<a class="headerlink" href="#task-9-experiment-with-the-tap-interface" title="Permalink to this headline">¶</a></h2>
<p>In this task, we will do a simple experiment with the TAP interface, so
students can get some idea of this type of interface. The way how the
TAP interface works is quite similar to the TUN interface. The main
difference is that the kernel end of the TUN interface is hooked to the
IP layer, while the kernel end of the TAP interface is hooked to the MAC
layer. Therefore, the packet going through the TAP interface includes
the MAC header, while the packet going through the TUN interface only
includes the IP header. Other than getting the frames containing IP
packets, using the TAP interface, applications can also get other types
of frames, such as ARP frames.</p>
<p>We will use the following program for our experiment, and we will only
use the VPN client container (either lab environment setup is fine). The
code for creating the TUN interface and TAP interface is quite similar;
the only difference is in the interface type. For TAP interfaces, we use
<code class="docutils literal notranslate"><span class="pre">IFF_TAP</span></code>, while for TUN, we use <code class="docutils literal notranslate"><span class="pre">IFF_TUN</span></code>. The rest of the code are
the same, so we do not include them in the following. The way to
configure a TAP interface is exactly the same as the way to configure a
TUN interface.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>...

tap = os.open(&quot;/dev/net/tun&quot;, os.O_RDWR)
ifr = struct.pack(&#39;16sH&#39;, b&#39;tap%d&#39;, IFF_TAP | IFF_NO_PI)
ifname_bytes  = fcntl.ioctl(tap, TUNSETIFF, ifr)
ifname = ifname_bytes.decode(&#39;UTF-8&#39;)[:16].strip(&quot;\x00&quot;)
...

while True:
   packet = os.read(tap, 2048)
   if packet:
      ether = Ether(packet)
      print(ether.summary())
</pre></div>
</div>
<p>The code above simply reads from the TAP interface. It then casts the
data to a Scapy <code class="docutils literal notranslate"><span class="pre">Ether</span></code> object, and prints out all its fields. Try to
<code class="docutils literal notranslate"><span class="pre">ping</span></code> an IP address in the <code class="docutils literal notranslate"><span class="pre">192.168.53.0/24</span></code> network; report and
explain your observations.</p>
<p>To make this more interesting, once you get an ethernet frame from the
TAP interface, you can check whether it is an ARP request; if it is,
generate a corresponding ARP reply and write it to the TAP interface. A
sample code is provided in the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>while True:
   packet = os.read(tun, 2048)
   if packet:
      print(&quot;--------------------------------&quot;)
      ether = Ether(packet)
      print(ether.summary())

      # Send a spoofed ARP response
      FAKE_MAC   = &quot;aa:bb:cc:dd:ee:ff&quot;
      if ARP in ether and ether[ARP].op == 1 :
         arp       = ether[ARP]
         newether  = Ether(dst=ether.src, src=FAKE_MAC)
         newarp    = ARP(psrc=arp.pdst, hwsrc=FAKE_MAC,
                         pdst=arp.psrc, hwdst=ether.src, op=2)
         newpkt     = newether/newarp

         print(&quot;***** Fake response: {}&quot;.format(newpkt.summary()))
         os.write(tun, bytes(newpkt))
</pre></div>
</div>
<p>To test your TAP program, you can run the <code class="docutils literal notranslate"><span class="pre">arping</span></code> command on any IP
address. This command sends out an ARP request for the specified IP
address via the specified interface. If your spoof-arp-reply TAP program
works, you should be able to get a response. See the following examples.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>arping -I tap0 192.168.53.33
arping -I tap0 1.2.3.4
</pre></div>
</div>
</div>
<div class="section" id="submission">
<h2>Submission<a class="headerlink" href="#submission" title="Permalink to this headline">¶</a></h2>
<p>You need to submit a detailed lab report, with screenshots, to describe what you have done and what you
have observed. You also need to provide explanation to the observations that are interesting or surprising.
Please also list the important code snippets followed by explanation. Simply attaching code without any
explanation will not receive credits.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="../web/web_index.html" class="btn btn-neutral float-right" title="Web Security Labs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="VPN.html" class="btn btn-neutral float-left" title="Virtual Private Network (VPN) Lab" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, NEXUS Lab.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>