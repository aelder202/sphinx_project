

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Virtual Private Network (VPN) Lab &mdash; Network Security Lab  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="VPN Lab: The Container Version" href="VPN_Tunnel.html" />
    <link rel="prev" title="TCP/IP Attack Lab" href="TCP_Attacks.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Network Security Lab
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../xie/xie_labs.html">Xie Labs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../seed_index.html">SEED Labs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../crypto/crypto_index.html">Cryptography Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hardware/hardware_index.html">Hardware Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mobile/mobile_index.html">Mobile Security Labs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="network_index.html">Network Security Labs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="arp_attack.html">ARP Cache Poisoning Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="bgp_basic.html">BGP Lab: Building an Internet Simulator</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_in_a_box.html">DNS In a Box</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_local.html">Local DNS Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_rebinding.html">DNS Rebinding Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_remote.html">The Kaminsky Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="dnssec.html">DNS Security Extensions (DNSSEC) Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="firewall.html">Firewall Exploration Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="firewall_vpn.html">Firewall Evasion Lab: Bypassing Firewalls using VPN</a></li>
<li class="toctree-l3"><a class="reference internal" href="Heartbleed.html">Heartbleed Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="ICMP_Redirect.html">ICMP Redirect Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Mitnick_Attack.html">The Mitnick Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Sniffing_Spoofing.html">Packet Sniffing and Spoofing Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="TCP_Attacks.html">TCP/IP Attack Lab</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Virtual Private Network (VPN) Lab</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lab-tasks">Lab Tasks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-1-vm-setup">Task 1: VM Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-2-creating-a-vpn-tunnel-using-tun-tap">Task 2: Creating a VPN Tunnel using TUN/TAP</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-3-encrypting-the-tunnel">Task 3: Encrypting the Tunnel</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-4-authenticating-the-vpn-server">Task 4: Authenticating the VPN Server</a></li>
<li class="toctree-l4"><a class="reference internal" href="#guidelines">Guidelines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#submission-and-demonstration">Submission and Demonstration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#checklist-for-demonstration">Checklist for Demonstration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="VPN_Tunnel.html">VPN Lab: The Container Version</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../web/web_index.html">Web Security Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../software/software_index.html">Software Security Labs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../website_link/web_index.html"><strong>Return To Website</strong></a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Network Security Lab</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../seed_index.html">SEED Labs</a> &raquo;</li>
        
          <li><a href="network_index.html">Network Security Labs</a> &raquo;</li>
        
      <li>Virtual Private Network (VPN) Lab</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="virtual-private-network-vpn-lab">
<h1>Virtual Private Network (VPN) Lab<a class="headerlink" href="#virtual-private-network-vpn-lab" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>A Virtual Private Network (VPN) is used for creating a private scope of
computer communications or providing a secure extension of a private
network into an insecure network such as the Internet. VPN is a widely
used security technology. VPN can be built upon IPSec or TLS/SSL
(Transport Layer Security/Secure Socket Layer). These are two
fundamentally different approaches for building VPNs. In this lab, we
focus on the TLS/SSL-based VPNs. This type of VPNs is often referred to
as TLS/SSL VPNs.</p>
<p>The learning objective of this lab is for students to master the network
and security technologies underlying VPNs. To achieve this goal,
students will be asked to implement a simple TLS/SSL VPN. Although this
VPN is simple, it does include all the essential elements of a VPN. The
design and implementation of TLS/SSL VPNs exemplify a number of security
principles, including the following:</p>
<ul class="simple">
<li>Virtual Private Network</li>
<li>TUN/TAP, and IP tunneling</li>
<li>Routing</li>
<li>Public-key cryptography, PKI, and X.509 certificate</li>
<li>TLS/SSL programming</li>
<li>Authentication</li>
</ul>
<p><strong>Readings and videos.</strong> Detailed coverage of VPN, PKI, and TLS can be found in the following:</p>
<ul class="simple">
<li>Chapters 19, 24, and 25 of the SEED Book, Computer &amp; Internet Security: A Hands-on Approach,
2nd Edition, by Wenliang Du. See details at <a class="reference external" href="https://www.handsonsecurity.net">https://www.handsonsecurity.net</a>.</li>
<li>Section 8 of the SEED Lecture, Internet Security: A Hands-on Approach, by Wenliang Du. See details
at <a class="reference external" href="https://www.handsonsecurity.net/video.html">https://www.handsonsecurity.net/video.html</a>.</li>
</ul>
<p><strong>Related labs.</strong> We have a separate SEED lab on PKI, and another one on TLS. It is
recommended that students finish these two crypto labs before working on
this comprehensive VPN lab. If students are only interested in the
tunneling part of the VPN (without the crypto part), they should use the
VPN Tunneling Lab, instead of this one.</p>
<p><strong>Lab Environment.</strong> We need to use the package in this lab. The package includes the header
files, libraries, and commands. The package was already installed in our
pre-built VM image.</p>
</div>
<div class="section" id="lab-tasks">
<h2>Lab Tasks<a class="headerlink" href="#lab-tasks" title="Permalink to this headline">¶</a></h2>
<p>In this lab, students need to implement a simple VPN for . We will call
it miniVPN.</p>
</div>
<div class="section" id="task-1-vm-setup">
<h2>Task 1: VM Setup<a class="headerlink" href="#task-1-vm-setup" title="Permalink to this headline">¶</a></h2>
<p>We will create a VPN tunnel between a computer (client) and a gateway,
allowing the computer to securely access a private network via the
gateway. We need at least three VMs: VPN client (also serving as Host
U), VPN server (the gateway), and a host in the private network (Host
V). The network setup is depicted in Figure&nbsp;1.</p>
<div class="figure align-center" id="id1">
<img alt="../../_images/vpn_img1.png" src="../../_images/vpn_img1.png" />
<p class="caption"><span class="caption-text">Figure 1: VM setup for this lab</span></p>
</div>
<p>In practice, the VPN client and VPN server are connected via the
Internet. For the sake of simplicity, we directly connect these two
machines to the same LAN in this lab, i.e., this LAN simulates the
Internet. We will use the “NAT Network” adaptor for this LAN. The third
machine, Host V, is a computer inside the private network. Users on Host
U (outside of the private network) want to communicate with Host V via
the VPN tunnel. To simulate this setup, we connect Host V to VPN Server
(also serving as a gateway) via an “Internal Network”. In such a setup,
Host V is not directly accessible from the Internet; nor is it directly
accessible from Host U.</p>
<p>Note if a VM uses the “Internal Network” mode, VirtualBox provides no
DHCP to it, so the VM must be statically configured. To do this, click
the network icon on the top-right corner of the desktop, and select
<code class="docutils literal notranslate"><span class="pre">&quot;Edit</span> <span class="pre">Connections&quot;</span></code>. You will see a list of <code class="docutils literal notranslate"><span class="pre">&quot;Wired</span> <span class="pre">connections&quot;</span></code>,
one for each of the network adaptors used by the VM. For Host V, there
is only one connection, but for VPN Server, we will see two. To make
sure that you pick the one that is corresponding to the “Internal
Network” adapter, You can check the MAC address displayed in the pop-up
window after you have picked a connection to edit. Compare this MAC
address with the one that you get from <code class="docutils literal notranslate"><span class="pre">ifconfig</span></code>, and you will know
whether you picked the right connection.</p>
<p>After you have selected the right connection to edit, pick the
<code class="docutils literal notranslate"><span class="pre">&quot;ipv4</span> <span class="pre">Settings&quot;</span></code> tab and select the <code class="docutils literal notranslate"><span class="pre">&quot;Manual&quot;</span></code> method, instead of
the default <code class="docutils literal notranslate"><span class="pre">&quot;Automatic</span> <span class="pre">(DHCP)&quot;</span></code>. Click the <code class="docutils literal notranslate"><span class="pre">&quot;Add&quot;</span></code> button to set up
the new IP address for the VM. See Figure&nbsp;2for details.</p>
<div class="figure align-center" id="id2">
<img alt="../../_images/vpn_img2.png" src="../../_images/vpn_img2.png" />
<p class="caption"><span class="caption-text">Figure 2: Manually set up the IP address for the <code class="docutils literal notranslate"><span class="pre">&quot;Internal</span> <span class="pre">Network&quot;</span></code> adaptor
on VPN Server.</span></p>
</div>
</div>
<div class="section" id="task-2-creating-a-vpn-tunnel-using-tun-tap">
<h2>Task 2: Creating a VPN Tunnel using TUN/TAP<a class="headerlink" href="#task-2-creating-a-vpn-tunnel-using-tun-tap" title="Permalink to this headline">¶</a></h2>
<p>The enabling technology for the TLS/SSL VPNs is TUN/TAP, which is now
widely implemented in modern operating systems. TUN and TAP are virtual
network kernel drivers; they implement network device that are supported
entirely in software. TAP (as in network tap) simulates an Ethernet
device and it operates with layer-2 packets such as Ethernet frames; TUN
(as in network TUNnel) simulates a network layer device and it operates
with layer-3 packets such as IP packets. With TUN/TAP, we can create
virtual network interfaces.</p>
<p>A user-space program is usually attached to the TUN/TAP virtual network
interface. Packets sent by an operating system via a TUN/TAP network
interface are delivered to the user-space program. On the other hand,
packets sent by the program via a TUN/TAP network interface are injected
into the operating system network stack; to the operating system, it
appears that the packets come from an external source through the
virtual network interface.</p>
<p>When a program is attached to a TUN/TAP interface, the IP packets that
the computer sends to this interface will be piped into the program; on
the other hand, the IP packets that the program sends to the interface
will be piped into the computer, as if they came from the outside
through this virtual network interface. The program can use the standard
read() and write() system calls to receive packets from or send packets
to the virtual interface.</p>
<p>We have created a sample VPN client program (<code class="docutils literal notranslate"><span class="pre">vpnclient</span></code>) and a server
program (<code class="docutils literal notranslate"><span class="pre">vpnserver</span></code>), both of which can be downloaded from this lab’s
web site. The programs are explained in details in Chapter 16 of the
SEED book titled <em>Computer &amp; Internet Security: A Hands-on Approach, 2nd
Edition</em>; the chapter also explains how TUN/TAP works and how to use it
to create VPN.</p>
<div class="figure align-center" id="id3">
<img alt="../../_images/vpn_img3.png" src="../../_images/vpn_img3.png" />
<p class="caption"><span class="caption-text">Figure 3: VPN client and server</span></p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">vpnclient</span></code> and <code class="docutils literal notranslate"><span class="pre">vpnserver</span></code> programs are the two ends of a VPN
tunnel. They communicate with each other using either TCP or UDP via the
sockets depicted in Figure&nbsp;3. In our
sample code, we choose to use UDP for the sake of simplicity. The dotted
line between the client and server depicts the path for the VPN tunnel.
The VPN client and server programs connect to the hosting system via a
TUN interface, through which they do two things: (1) get IP packets from
the hosting system, so the packets can be sent through the tunnel, (2)
get IP packets from the tunnel, and then forward it to the hosting
system, which will forward the packet to its final destination. The
following procedure describes how to create a VPN tunnel using the
<code class="docutils literal notranslate"><span class="pre">vpnclient</span></code> and <code class="docutils literal notranslate"><span class="pre">vpnserver</span></code> programs.</p>
<p><strong>Step 1: Run VPN Server.</strong> We first run the VPN server program <code class="docutils literal notranslate"><span class="pre">vpnserver</span></code> on the Server VM.
After the program runs, a virtual TUN network interface will appear in
the system (we can see it using the <code class="docutils literal notranslate"><span class="pre">&quot;ifconfig</span> <span class="pre">-a&quot;</span></code> command; the name
of the interface will be <code class="docutils literal notranslate"><span class="pre">tun0</span></code> in most cases, but they can be
<code class="docutils literal notranslate"><span class="pre">tunX</span></code>, where <code class="docutils literal notranslate"><span class="pre">X</span></code> is a number). This new interface is not yet
configured, so we need to configure it by giving it an IP address. We
use <code class="docutils literal notranslate"><span class="pre">192.168.53.1</span></code> for this interface.</p>
<p>Run the following commands. The first command will start the server
program, and the second command assigns an IP address to the <code class="docutils literal notranslate"><span class="pre">tun0</span></code>
interface and then activates it. It should be noted that the first
command will block and wait for connections, so we need to find another
window run the second command.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo ./vpnserver

Run the following command in another window:
$ sudo ifconfig tun0 192.168.53.1/24 up
</pre></div>
</div>
<p>Unless specifically configured, a computer will only act as a host, not
as a gateway. The VPN Server needs to forward packets between the
private network and the tunnel, so it needs to function as a gateway. We
need to enable the IP forwarding for a computer to behave like a
gateway. IP forwarding can be enabled using the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo sysctl net.ipv4.ip_forward=1
</pre></div>
</div>
<p><strong>Step 2: Run VPN Client.</strong> We now run the VPN client program on the Client VM. We run the following
commands on this machine. The first command will connect to the VPN
server program (the server’s IP address is hardcoded inside the program,
and you need to change it accordingly). This command will block as well,
so we need to find another window to configure the <code class="docutils literal notranslate"><span class="pre">tun0</span></code> interface
created by the VPN client program. We assign IP address <code class="docutils literal notranslate"><span class="pre">192.168.53.5</span></code>
to the <code class="docutils literal notranslate"><span class="pre">tun0</span></code> interface.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>On VPN Client VM:
$ sudo ./vpnclient

Run the following command in a different window
$ sudo ifconfig tun0 192.168.53.5/24 up
</pre></div>
</div>
<p><strong>Step 3: Set Up Routing on Client and Server VMs:</strong> After the above
two steps, the tunnel will be established. Before we can
use the tunnel, we need to set up routing paths on both client and
server machines to direct the intended traffic through the tunnel. On
the client machine, we need to direct all the packets going to the
private network (192.168.60.0/24) towards the <code class="docutils literal notranslate"><span class="pre">tun0</span></code> interface, from
where the packets can be forwarded through the VPN tunnel. Without this
setup, we will not be able to access the private network at all. We can
use the <code class="docutils literal notranslate"><span class="pre">route</span></code> command to add an routing entry. The following example
shows how to route the <code class="docutils literal notranslate"><span class="pre">10.20.30.0/24</span></code>-bound packets to the interface
<code class="docutils literal notranslate"><span class="pre">eth0</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo route add -net 10.20.30.0/24 eth0
</pre></div>
</div>
<p>On both client and server machines, we also need to set up a routing
entry so all the traffic going to the <code class="docutils literal notranslate"><span class="pre">192.168.53.0/24</span></code> network are
directed to the <code class="docutils literal notranslate"><span class="pre">tun0</span></code> interface. This entry will usually be
automatically added when we assign <code class="docutils literal notranslate"><span class="pre">192.169.53.X</span></code> to the <code class="docutils literal notranslate"><span class="pre">tun0</span></code>
interface. If for some reasons it is not added, we can use the <code class="docutils literal notranslate"><span class="pre">route</span></code>
command to add it.</p>
<p><strong>Step 4: Set Up Routing on Host V.</strong> When Host V replies to a packet
sent from Host U, it needs to route the
packets to the VPN Server VM, from where, it can be fed into the VPN
tunnel toward the other end. You need to find out what entry to add, and
then use the <code class="docutils literal notranslate"><span class="pre">route</span></code> command to add the routing entry. Hint: when Host
V receives a packet from Host U (via the tunnel), you need to know what
the source IP is in the packet; in the reply packet, the source IP
becomes the destination IP, which will be used by the routing table.
Therefore, you need to figure out the source IP of the packets from U to
V. It is your task to figure this out and set the routing correctly in
this step.</p>
<p><strong>Step 5: Test the VPN Tunnel:</strong> After everything is set up, we
can access Host V from Host U via the
tunnel. Please conduct the following tests using <code class="docutils literal notranslate"><span class="pre">ping</span></code> and
<code class="docutils literal notranslate"><span class="pre">telnet</span></code>; please report your results. You should use Wireshark to
capture the network traffics on all the interfaces on the client VM, and
pinpoint which packets are part of the tunnel traffic, and which packets
are not the tunnel traffic.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>On Host U:
$ ping 192.168.60.101
$ telnet 192.168.60.101
</pre></div>
</div>
<p><strong>Step 6: Tunnel-Breaking Test.</strong> On Host U, <code class="docutils literal notranslate"><span class="pre">telnet</span></code> to <code class="docutils literal notranslate"><span class="pre">Host</span> <span class="pre">V</span></code>. While keeping the <code class="docutils literal notranslate"><span class="pre">telnet</span></code>
connection alive, we break the VPN tunnel. We then type something in the
<code class="docutils literal notranslate"><span class="pre">telnet</span></code> window, and report what you observe. We then reconnect the
VPN tunnel. What is going to happen to the <code class="docutils literal notranslate"><span class="pre">telnet</span></code> connection? Will
it be broken or resumed? Please describe and explain your observations.</p>
</div>
<div class="section" id="task-3-encrypting-the-tunnel">
<h2>Task 3: Encrypting the Tunnel<a class="headerlink" href="#task-3-encrypting-the-tunnel" title="Permalink to this headline">¶</a></h2>
<p>At this point, we have created an IP tunnel, but our tunnel is not
protected. Only after we have secured this tunnel, can we call it a VPN
tunnel. This is what we are going to achieve in this task. To secure
this tunnel, we need to achieve two goals, confidentiality and
integrity. The confidentiality is achieved using encryption, i.e., the
contents that go through the tunnel is encrypted. The integrity goal
ensures that nobody can tamper with the traffic in the tunnel or launch
a replay attack. Integrity can be achieved using Message Authentication
Code (MAC). Both goals can be achieved using Transport Layer Protocol
(TLS).</p>
<p>TLS is typically built on top of TCP. The sample VPN client and server
programs in Task 2 use UDP, so we first need to replace the UDP channel
in the sample code with a TCP channel, and then establish a TLS session
between the two ends of the tunnel. A sample TLS client and server
program (<code class="docutils literal notranslate"><span class="pre">tlsclient</span></code> and <code class="docutils literal notranslate"><span class="pre">tlsserver</span></code>) is provided in a zip file that
can be downloaded from the website. Instructions on how to compile and
run the code is provided in the README file included in the zip file.
For detailed explanation of the sample code, please read Chapter 25 of
the SEED book (<em>Computer &amp; Internet Security: A Hands-on Approach, 2nd
Edition</em>). In your demonstration, you need to use Wireshark to capture
the traffic inside the VPN tunnel, and show that the traffic is indeed
encrypted.</p>
</div>
<div class="section" id="task-4-authenticating-the-vpn-server">
<h2>Task 4: Authenticating the VPN Server<a class="headerlink" href="#task-4-authenticating-the-vpn-server" title="Permalink to this headline">¶</a></h2>
<p>Before a VPN is established, the VPN client must authenticate the VPN
server, making sure that the server is not a fraudulent one. On the
other hand, the VPN server must authenticate the client (i.e. user),
making sure that the user has the permission to access the private
network. In this task, we implement the server authentication; the
client authentication is in the next task.</p>
<p>A typical way to authenticate servers is to use public-key certificates.
The VPN server needs to first get a public-key certificate from a
Certificate Authority (CA). When a client makes a connection to the VPN
server, the server will use the certificate to prove it is the intended
server. The HTTPS protocol uses this approach to authenticate web
servers, ensuring that you are talking to an intended web server, not a
fake one.</p>
<p>In this lab, MiniVPN should use such a method to authenticate the VPN
server. We can implement an authentication protocol (such as TLS/SSL)
from the scratch, but fortunately, <code class="docutils literal notranslate"><span class="pre">openssl</span></code> has taken care most of
the work for us. We just need to configure our TLS session properly, so
<code class="docutils literal notranslate"><span class="pre">openssl</span></code> can conduct the authentication automatically for us.</p>
<p>There are three important steps in server authentication: (1) verifying
that the server certificate is valid, (2) verifying that the server is
the owner of the certificate, and (3) verifying that the server is the
intended server (for example, if the user intends to visit
<code class="docutils literal notranslate"><span class="pre">example.com</span></code>, we need to ensure that the server is indeed
<code class="docutils literal notranslate"><span class="pre">example.com</span></code>, not another site). Please point out what lines of the
code in your program carry out the above verifications. In your
demonstration, you need to demonstrate two different cases regarding the
third verification: a successful server authentication where the server
is the intended server, and a failed server authentication where the
server is not the intended server.</p>
<p><strong>Note:</strong> Our MiniVPN program should be able to communicate with VPN servers on
different machines, so you cannot hardcode the hostname of the VPN
server in the program. The hostname needs to be typed in from the
command line. This name represents the user’s intention, so it should be
used in the verification. This name should also be used to find the IP
address of the server. Section&nbsp;3.2 provides a sample program to show you
how to get the IP address for a given hostname.</p>
<p><strong>Our sample TLS client and server programs.</strong> Server authentication is implemented in the sample programs provided by
us. Part of the authentication requires the certificate of the CA who
issues the server certificate. We have put two CA certificates in the
<code class="docutils literal notranslate"><span class="pre">./ca_client</span></code> folder: one is the CA that issues our server’s
certificate (the hostname of the server is
vpnlabserver.com), and the other is the CA that
issues Google’s certificate. Therefore, the sample TLS client program
can talk to our own server, as well as Google’s HTTPS server:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ./tlsclient vpnlabserver.com 4433
$ ./tlsclient www.google.com 443
</pre></div>
</div>
<p><strong>It should be noted</strong> that students should not use <code class="docutils literal notranslate"><span class="pre">vpnlabserver.com</span></code>
from the sample code as their VPN server name; instead, <strong>they should
include their last name</strong> in the server name. Students should generate
their own CA in order to create server certificates. The objective of
this requirement is to differentiate student’s work.</p>
<p>To use our client to talk to an HTTPS server, we need to get its CA’s
certificate, save the certificate in the <code class="docutils literal notranslate"><span class="pre">./ca_client</span></code> folder, and
create a symbolic link to it&nbsp;(or rename it) using the hash value
generated from its subject field. For example, to enable our client to
talk to Google, who gets its certificate from a root CA called “GeoTrust
Global CA”, we get this root CA’s certificate (<code class="docutils literal notranslate"><span class="pre">GeoTrustGlobalCA.pem</span></code>)
from the Firefox browser, and run the following command to get its hash
and then set up the symbolic link:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ openssl x509 -in GeoTrustGlobalCA.pem -noout -subject_hash
2c543cd1

$ ln -s GeoTrustGlobalCA.pem 2c543cd1.0
$ ls -l
lrwxrwxrwx 1 ... 2c543cd1.0 -&gt; GeoTrustGlobalCA.pem
lrwxrwxrwx 1 ... 9b58639a.0 -&gt; cacert.pem
-rw-r--r-- 1 ... cacert.pem
-rw-r--r-- 1 ... GeoTrustGlobalCA.pem
</pre></div>
</div>
<div class="section" id="task-5-authenticating-the-vpn-client">
<h3>Task 5: Authenticating the VPN Client<a class="headerlink" href="#task-5-authenticating-the-vpn-client" title="Permalink to this headline">¶</a></h3>
<p>Accessing the machines inside a private network is a privilege that is
only granted to authorized users, not to everybody. Therefore, only
authorized users are allowed to establish a VPN tunnel with the VPN
server. In this task, authorized users are those who have a valid
account on the VPN server. We will therefore use the standard password
authentication to authenticate users. Basically, when a user tries to
establish a VPN tunnel with the VPN server, the user will be asked to
provide a user name and a password. The server will check its shadow
file (<code class="docutils literal notranslate"><span class="pre">/etc/shadow</span></code>); if a matching record is found, the user is
authenticated, and the VPN tunnel will be established. If there is no
match, the server will break its connection with the user, and thus no
tunnel will be established. See Section&nbsp;3.3 for
sample code on how to authenticate users using the shadow file.</p>
</div>
<div class="section" id="task-6-supporting-multiple-clients">
<h3>Task 6: Supporting Multiple Clients<a class="headerlink" href="#task-6-supporting-multiple-clients" title="Permalink to this headline">¶</a></h3>
<p>In the real world, one VPN server often supports multiple VPN tunnels.
Namely, the VPN server allows more than one clients to connect to it
simultaneously, with each client having its own VPN tunnel (and thus its
own TLS session). Our MiniVPN should support multiple clients.</p>
<div class="figure align-center" id="id4">
<img alt="../../_images/vpn_img4.png" src="../../_images/vpn_img4.png" />
<p class="caption"><span class="caption-text">Figure 4: Supporting multiple VPN clients</span></p>
</div>
<p>In a typical implementation, the VPN server process (the parent process)
will create a child process for each tunnel (see
Figure&nbsp;3). When a packet comes from the
tunnel, its corresponding child process will get the packet, and forward
it to the TUN interface. This direction is the same regardless of
whether multiple clients are supported or not. It is the other direction
that becomes challenging. When a packet arrives at the TUN interface
(from the private network), the parent process will get the packet, now
it needs to figure out which tunnel this packet should go to. You need
to think about how to implement this decision-making logic.</p>
<p>Once the decision is made and a tunnel is selected, the parent process
needs to send the packet to the child process, to which the selected
tunnel is attached. This calls for IPC (Inter-Process Communication). A
typical approach is to use pipes. We provide a sample program in
Section&nbsp;3.4 to demonstrate how to use pipes for
IPC.</p>
<p>Child processes need to monitor this pipe interface, and read data from
it if there are data. Since child processes also need to watch out for
data coming from the socket interface, they need to simultaneously
monitor multiple interfaces. Section&nbsp;3.5
shows how to achieve that.</p>
</div>
</div>
<div class="section" id="guidelines">
<h2>Guidelines<a class="headerlink" href="#guidelines" title="Permalink to this headline">¶</a></h2>
<div class="section" id="displaying-tls-traffic-in-wireshark">
<h3>Displaying TLS Traffic in Wireshark<a class="headerlink" href="#displaying-tls-traffic-in-wireshark" title="Permalink to this headline">¶</a></h3>
<p>Wireshark identifies TLS/SSL traffic based on port numbers. It knows
<code class="docutils literal notranslate"><span class="pre">443</span></code> is the default port number for HTTPS, but our VPN server listens
to a different and non-standard port number. We need to let Wireshark
know that; otherwise, Wireshark will not label our traffic as SSL/TLS
traffic. Here is what we can do: go to the <code class="docutils literal notranslate"><span class="pre">Edit</span></code> menu in Wireshark,
and click <code class="docutils literal notranslate"><span class="pre">Preferences</span></code>, <code class="docutils literal notranslate"><span class="pre">Protocols</span></code>, <code class="docutils literal notranslate"><span class="pre">HTTP</span></code>, and then find the
<code class="docutils literal notranslate"><span class="pre">&quot;SSL/TLS</span> <span class="pre">Ports&quot;</span></code> entry. Add your SSL server port. For example, we can
change the content of the entry to <code class="docutils literal notranslate"><span class="pre">443,4433</span></code>, where <code class="docutils literal notranslate"><span class="pre">4433</span></code> is the
port used by our SSL server.</p>
<p><strong>Displaying decrypted traffic.</strong> The approach shown above only gets Wireshark to recognize the traffic as
TLS/SSL traffic; Wireshark cannot decrypt the encrypted traffic. For
debugging purposes, we would like to see the decrypted traffic.
Wireshark provides such a feature; all we need to do is to provide the
server’s private key to Wireshark, and Wireshark will automatically
derive the session keys from the TLS/SSL handshake protocol, and use
these keys to decrypt traffic. To provide the server’s private key to
Wireshark, do the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Click Edit -&gt; Preferences -&gt; Protocols -&gt; SSL
Find the &quot;RSA key list&quot;, and click the Edit button
Provide the required information about the server, see this example:
     IP Address: 10.0.2.65
     Port:       4433
     Protocol:   ssl
     Key File:   /home/seed/vpn/server-key.pem  (privat key file)
     Password:   deesdees
</pre></div>
</div>
</div>
<div class="section" id="getting-ip-address-from-hostname">
<h3>Getting IP Address from Hostname<a class="headerlink" href="#getting-ip-address-from-hostname" title="Permalink to this headline">¶</a></h3>
<p>Given a hostname, we can get the IP address for this name. In our sample
<code class="docutils literal notranslate"><span class="pre">tlsclient</span></code> program, we use the <code class="docutils literal notranslate"><span class="pre">gethostbyname()</span></code> function to get
the IP address. However, this function is obsolete because it does not
support IPV6. Applications should use <code class="docutils literal notranslate"><span class="pre">getaddrinfo()</span></code> instead. The
following example shows to how to use this function to get IP addresses.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;

struct addrinfo  hints, *result;

int main() {

  hints.ai_family = AF_INET; // AF_INET means IPv4 only addresses

  int error = getaddrinfo(&quot;www.example.com&quot;, NULL, &amp;hints, &amp;result);
  if (error) {
      fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(error));
      exit(1);
  }

  // The result may contain a list of IP address; we take the first one.
  struct  sockaddr_in*  ip = (struct sockaddr_in *) result-&gt;ai_addr;
  printf(&quot;IP Address: %s\n&quot;, (char *)inet_ntoa(ip-&gt;sin_addr));

  freeaddrinfo(result);
  return 0;
}
</pre></div>
</div>
</div>
<div class="section" id="authentication-using-the-shadow-file">
<h3>Authentication Using the Shadow File<a class="headerlink" href="#authentication-using-the-shadow-file" title="Permalink to this headline">¶</a></h3>
<p>The following program shows how to authenticate a user using the account
information stored in the shadow file. The program uses <code class="docutils literal notranslate"><span class="pre">getspnam()</span></code>
to get a given user’s account information from the shadow file,
including the hashed password. It then uses <code class="docutils literal notranslate"><span class="pre">crypt()</span></code> to hash a given
password and see whether the result matches with the values fetched from
the shadow file. If so, the user name and the password match, and the
authentication is successful.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;shadow.h&gt;
#include &lt;crypt.h&gt;

int login(char *user, char *passwd)
{
    struct spwd *pw;
    char *epasswd;

    pw = getspnam(user);
    if (pw == NULL) {
        return -1;
    }

    printf(&quot;Login name: %s\n&quot;, pw-&gt;sp_namp);
    printf(&quot;Passwd    : %s\n&quot;, pw-&gt;sp_pwdp);

    epasswd = crypt(passwd, pw-&gt;sp_pwdp);
    if (strcmp(epasswd, pw-&gt;sp_pwdp)) {
        return -1;
    }

    return 1;
}

void main(int argc, char** argv)
{
   if (argc &lt; 3) {
       printf(&quot;Please provide a user name and a password\n&quot;);
       return;
   }

   int r = login(argv[1], argv[2]);
   printf(&quot;Result: %d\n&quot;, r);
}
</pre></div>
</div>
<p>We can compile the code above and run it with a user name and a
password. It should be noted that the root privilege is needed when
reading from the shadow file. See the following commands for compilation
and execution.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gcc login.c -lcrypt
$ sudo ./a.out seed dees
</pre></div>
</div>
<p>It should be noted that we use <code class="docutils literal notranslate"><span class="pre">-lcrypt</span></code> in the above compilation; we
used <code class="docutils literal notranslate"><span class="pre">-lcrypto</span></code> when compiling our TLS programs. The <code class="docutils literal notranslate"><span class="pre">crypt</span></code> and
<code class="docutils literal notranslate"><span class="pre">crypto</span></code> are two different libraries, so this is not a typo.</p>
</div>
<div class="section" id="inter-process-communication-using-pipe">
<h3>Inter-Process Communication Using Pipe<a class="headerlink" href="#inter-process-communication-using-pipe" title="Permalink to this headline">¶</a></h3>
<p>The following program shows how a parent process sends data to its child
process using pipe. The parent process creates a pipe using <code class="docutils literal notranslate"><span class="pre">pipe()</span></code>
in Line&nbsp;➀. Each pipe has two ends: the input end’s file descriptor is
<code class="docutils literal notranslate"><span class="pre">fd[0]</span></code>, and the output end’s file descriptor is <code class="docutils literal notranslate"><span class="pre">fd[1]</span></code>.</p>
<p>After the pipe is created, a child process is spawned using <code class="docutils literal notranslate"><span class="pre">fork()</span></code>.
Both parent and child processes have the file descriptors associated
with the pipe. They can send data to each other using the the pipe,
which is bi-directional. However, we will only use this pipe to send
data from the parent process to the child process, and the parent will
not read anything from the pipe, so we close the input end <code class="docutils literal notranslate"><span class="pre">fd[0]</span></code> in
the parent process. Similarly, the child does not send anything via the
pipe, so it closes the output end <code class="docutils literal notranslate"><span class="pre">fd[1]</span></code>. At this point, we have
established a uni-directional pipe from the parent process to the child
process. To send data via the pipe, the parent process writes to
<code class="docutils literal notranslate"><span class="pre">fd[1]</span></code> (see Line&nbsp;➁); to receive data from the pipe, the child process
reads from <code class="docutils literal notranslate"><span class="pre">fd[0]</span></code> (see Line&nbsp;➂).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  int     fd[2], nbytes;
  pid_t   pid;
  char    string[] = &quot;Hello, world!\n&quot;;
  char    readbuffer[80];

  pipe(fd);                                                  ➀

  if((pid = fork()) == -1) {
       perror(&quot;fork&quot;);
       exit(1);
  }

  if(pid&gt;0) { //parent process
       close(fd[0]); // Close the input end of the pipe.

       // Write data to the pipe.
       write(fd[1], string, (strlen(string)+1));             ➁
       exit(0);
  }
  else { //child process
       close(fd[1]); // Close the output end of the pipe.

       // Read data from the pipe.
       nbytes = read(fd[0], readbuffer, sizeof(readbuffer)); ➂
       printf(&quot;Child process received string: %s&quot;, readbuffer);
  }
  return(0);
}
</pre></div>
</div>
</div>
<div class="section" id="using-select-to-monitor-multiple-input-interfaces">
<h3>Using <code class="docutils literal notranslate"><span class="pre">select</span></code> to Monitor Multiple Input Interfaces<a class="headerlink" href="#using-select-to-monitor-multiple-input-interfaces" title="Permalink to this headline">¶</a></h3>
<p>Our VPN program needs to monitor multiple interfaces, including the TUN
interface, the socket interface, and sometimes, the pipe interface. All
these interfaces are represented by file descriptors, so we need to
monitor them to see whether there are data coming from them. One way to
do that is to keep polling them, and see whether there are data on each
of the interfaces. The performance of this approach is undesirable,
because the process has to keep running in an idle loop when there is no
data. Another way is to read from an interface. By default, read is
blocking, i.e., the process will be suspended if there are no data. When
data become available, the process will be unblocked, and its execution
will continue. This way, it does not waste CPU time when there is no
data.</p>
<p>The read-based blocking mechanism works well for one interface. If a
process is waiting on multiple interfaces, it cannot block on just one
of the interfaces. It has to block on all of them altogether. has a
system call called <code class="docutils literal notranslate"><span class="pre">select()</span></code>, which allows a program to monitor
multiple file descriptors simultaneously. To use <code class="docutils literal notranslate"><span class="pre">select()</span></code>, we need
to store all the file descriptors to be monitored in a set using the
<code class="docutils literal notranslate"><span class="pre">FD_SET</span></code> macro&nbsp;(see Lines&nbsp;➀ and&nbsp;➁ in the code below). We then give the
set to the <code class="docutils literal notranslate"><span class="pre">select()</span></code> system call&nbsp;(Line&nbsp;➂), which will block the
process until data are available on one of the file descriptors in the
set. We can then use the <code class="docutils literal notranslate"><span class="pre">FD_ISSET</span></code> macro to figure out which file
descriptor has received data. In the following code example, we use
<code class="docutils literal notranslate"><span class="pre">select()</span></code> to monitor a <code class="docutils literal notranslate"><span class="pre">TUN</span></code> and a socket file descriptor.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>fd_set readFDSet;
int ret, sockfd, tunfd;

FD_ZERO(&amp;readFDSet);
FD_SET(sockfd, &amp;readFDSet);                                ➀
FD_SET(tunfd, &amp;readFDSet);                                 ➁
ret = select(FD_SETSIZE, &amp;readFDSet, NULL, NULL, NULL);    ➂

if (FD_ISSET(sockfd, &amp;readFDSet){
        // Read data from sockfd, and do something.
}

if (FD_ISSET(tunfd, &amp;readFDSet){
        // Read data from tunfd, and do something.
}
</pre></div>
</div>
</div>
<div class="section" id="an-example-using-telnet-in-our-vpn">
<h3>An example: using telnet in our VPN<a class="headerlink" href="#an-example-using-telnet-in-our-vpn" title="Permalink to this headline">¶</a></h3>
<p>To help you fully understand how packets from an application flow to its
destination through our MiniVPN, we have drawn two figures to illustrate
the complete packet flow path when users run telnet 10.0.20.100 from a
host machine, which is the Point A of a host-to-gateway VPN. The other
end of the VPN is on a gateway, which is connected to the 10.0.20.0/24
network, where our telnet server 10.0.20.100 resides.</p>
<p>Figure&nbsp;5(a) shows how a packet flow from the telnet client to the server.
Figure&nbsp;5(b) shows how a packet flow from the telnet server back to the
client. We will only describe the path in Figure&nbsp;5(a) in the following.
The return path is self-explained from Figure&nbsp;5(b) once you have understood
the path in Figure&nbsp;5(a).</p>
<ol class="arabic simple">
<li>The data of the packet starts from the telnet program.</li>
<li>The kernel will construct an IP packet, with the destination IP
address being 10.0.20.100.</li>
<li>The kernel needs to decide which network interface the packet should
be routed through: eth1 or tun0. You need to set up your routing
table correctly for the kernel to pick tun0. Once the decision is
made, the kernel will set the source IP address of the packet using
the IP address of the network interface, which is 10.0.4.1.</li>
<li>The packet will reach our VPN program (Point A) through the virtual
interface tun0, then it will be encrypted, and then be sent back to
the kernel through a UDP port (not through the tun0 interface). This
is because our VPN program use the UDP as our tunnel.</li>
<li>The kernel will treat the encrypted IP packet as UDP data, construct
a new IP packet, and put the entire encrypted IP packet as its UDP
payload. The new IP’s destination address will be the other end of
the tunnel (decided by the VPN program we write); in the figure, the
new IP’s destination address is 128.230.208.97.</li>
<li>You need to set up your routing table correctly, so the new packet
will be routed through the interaface eth1; therefore, the source IP
address of this new packet should be 209.164.131.32.</li>
<li>The packet will now flow through the Internet, with the original
telnet packet being entirely encrypted, and carried in the payload of
the packet. This is why it is called a tunnel.</li>
<li>The packet will reach our gateway 128.230.208.97 through its
interface eth1.</li>
<li>The kernel will give the UDP payload (i.e. the encrypted IP packet)
to the VPN program (Point B), which is waiting for UDP data. This is
through the UDP port.</li>
<li>The VPN program will decrypt the payload, and then feed the decrypted
payload, which is the original telnet packet, back to the kernel
through the virtual network interface tun0.</li>
<li>Since it comes through a network interface, the kernel will treat it
as an IP packet (it is indeed an IP packet), look at its destination
IP address, and decide where to route it. Remember, the destination
IP address of this packet is 10.0.20.100. If your routing table is
set up correctly, the packet should be routed through eth2, because
this is the interface that connects to the 10.0.20.0/24 network.</li>
<li>The telnet packet will now be delivered to its final destination
10.0.20.100.</li>
</ol>
</div>
</div>
<div class="section" id="submission-and-demonstration">
<h2>Submission and Demonstration<a class="headerlink" href="#submission-and-demonstration" title="Permalink to this headline">¶</a></h2>
<p>You should submit a detailed lab report to describe your design and implementation.
You should also describe how you test the functionalities and security of
your system. You also need to demonstrate your system to us. Please sign up
a demonstration time slot with the TA. Please take the following into
consideration when you prepare for demonstraiton:</p>
<ul class="simple">
<li>The total time of the demo will be 15 minutes, no more additional time would be given. So prepare
your demonstration so you can cover the important features.</li>
<li>You are entirely responsible for showing the demo. We will NOT even touch the keyboard during
the demonstration; so you should not depend on us to test your system. If you fail to demo some
important features of your system, we will assume that your system does not have those features.</li>
<li>You need to practice before you come to the demonstration. If the system crashes or anything goes
wrong, it is your own fault. We will not debug your problems, nor give you extra time for it.</li>
<li>During the demo, you should consider yourself as salesmen, and you want to sell your system to us.
You are given 15 minutes to show us how good your system is. So think about your sales strategies.
If you have implemented a great system, but fail to show us how good it is, you are not likely to get a
good grade.</li>
<li>Do turn off the messages your system prints out for debugging purposes. Those messages should not
appear in a demonstration.</li>
</ul>
</div>
<div class="section" id="checklist-for-demonstration">
<h2>Checklist for Demonstration<a class="headerlink" href="#checklist-for-demonstration" title="Permalink to this headline">¶</a></h2>
<p>During the COVID-19 outbreak, we cannot do in-person demo. Although
doing demo online is an option, we decide to experiment with a different
approach: asking students to record their demo and submit the video
file. To help them conduct a self-guided demo, we provide a checklist in
Table&nbsp;1. Even if we do in-person demo, this checklist is still quite useful.</p>
<div class="figure align-center" id="id5">
<img alt="../../_images/vpn_img5.png" src="../../_images/vpn_img5.png" />
<p class="caption"><span class="caption-text">Figure 5: An Example of Packet Flow in VPN</span></p>
</div>
<div class="figure align-center" id="id6">
<img alt="../../_images/vpn_img6.png" src="../../_images/vpn_img6.png" />
<p class="caption"><span class="caption-text">Table 1(a): Checklist for VPN demonstration</span></p>
</div>
<div class="figure align-center" id="id7">
<img alt="../../_images/vpn_img7.png" src="../../_images/vpn_img7.png" />
<p class="caption"><span class="caption-text">Table 1(b): Checklist for VPN demonstration</span></p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="VPN_Tunnel.html" class="btn btn-neutral float-right" title="VPN Lab: The Container Version" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="TCP_Attacks.html" class="btn btn-neutral float-left" title="TCP/IP Attack Lab" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, NEXUS Lab.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>